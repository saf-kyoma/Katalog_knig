

===== bookstorage/src/main/java/org/application/bookstorage\BookstorageApplication.java =====

package org.application.bookstorage;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SpringBootApplication
public class BookstorageApplication {

	// LOGGING ADDED
	private static final Logger logger = LoggerFactory.getLogger(BookstorageApplication.class);

	public static void main(String[] args) {
		// LOGGING ADDED
		logger.info("Запуск приложения BookstorageApplication...");

		SpringApplication.run(BookstorageApplication.class, args);

		// LOGGING ADDED
		logger.info("Приложение BookstorageApplication успешно запущено.");
	}
}


===== bookstorage/src/main/java/org/application/bookstorage\config\JacksonTestConfig.java =====

package org.application.bookstorage.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class JacksonTestConfig {

    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        // Регистрируем модуль для поддержки Java 8 типов даты/времени (LocalDate, LocalDateTime и т.д.)
        mapper.registerModule(new JavaTimeModule());
        // Отключаем запись дат в виде массивов – мы хотим видеть ISO‑строки (например, "2020-01-01")
        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        return mapper;
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\controller\author\AuthorController.java =====

package org.application.bookstorage.controller.author;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.Author;
import org.application.bookstorage.dto.AuthorDTO;
import org.application.bookstorage.service.author.AuthorService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/api/authors")
@RequiredArgsConstructor
public class AuthorController {

    private final AuthorService authorService;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(AuthorController.class);

    // Создание автора
    @PostMapping
    public ResponseEntity<AuthorDTO> createAuthor(@Valid @RequestBody AuthorDTO authorDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на создание автора: {}", authorDTO);

        Author author = mapToEntity(authorDTO);
        Author createdAuthor = authorService.createAuthor(author);

        // LOGGING ADDED
        logger.info("Автор успешно создан с ID: {}", createdAuthor.getId());

        AuthorDTO responseDTO = mapToDTO(createdAuthor);
        return new ResponseEntity<>(responseDTO, HttpStatus.CREATED);
    }

    // Получение автора по ID
    @GetMapping("/{id}")
    public ResponseEntity<AuthorDTO> getAuthorById(@PathVariable int id) {
        // LOGGING ADDED
        logger.info("Получен запрос на поиск автора по ID: {}", id);

        return authorService.getAuthorById(id)
                .map(author -> {
                    // LOGGING ADDED
                    logger.info("Автор найден: {}", author.getId());
                    return new ResponseEntity<>(mapToDTO(author), HttpStatus.OK);
                })
                .orElseGet(() -> {
                    // LOGGING ADDED
                    logger.warn("Автор с ID {} не найден", id);
                    return new ResponseEntity<>(HttpStatus.NOT_FOUND);
                });
    }

    // Получение всех авторов с поддержкой сортировки
    @GetMapping
    public ResponseEntity<List<AuthorDTO>> getAllAuthors(
            @RequestParam(required = false, name = "sort_column") String sortColumn,
            @RequestParam(required = false, name = "sort_order") String sortOrder) {
        // LOGGING ADDED
        logger.info("Получен запрос на получение всех авторов с параметрами сортировки: sort_column={}, sort_order={}",
                sortColumn, sortOrder);

        List<Author> authors = authorService.getAllAuthors();

        // Применяем сортировку, если она задана
        if (sortColumn != null && sortOrder != null) {
            Comparator<Author> comparator = getComparator(sortColumn);
            if ("desc".equalsIgnoreCase(sortOrder)) {
                comparator = comparator.reversed();
            }
            authors = authors.stream()
                    .sorted(comparator)
                    .collect(Collectors.toList());

            // LOGGING ADDED
            logger.info("Список авторов отсортирован по столбцу '{}' в порядке '{}'", sortColumn, sortOrder);
        }

        List<AuthorDTO> authorDTOs = authors.stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());

        // LOGGING ADDED
        logger.info("Возвращено {} авторов", authorDTOs.size());

        return new ResponseEntity<>(authorDTOs, HttpStatus.OK);
    }

    // Добавление метода поиска авторов
    @GetMapping("/search")
    public ResponseEntity<List<AuthorDTO>> searchAuthors(
            @RequestParam("q") String query,
            @RequestParam(required = false, name = "sort_column") String sortColumn,
            @RequestParam(required = false, name = "sort_order") String sortOrder) {
        // LOGGING ADDED
        logger.info("Получен запрос на поиск авторов. Запрос: {}, sort_column={}, sort_order={}",
                query, sortColumn, sortOrder);

        List<Author> authors = authorService.searchAuthors(query);

        // Применяем сортировку, если она задана
        if (sortColumn != null && sortOrder != null) {
            Comparator<Author> comparator = getComparator(sortColumn);
            if ("desc".equalsIgnoreCase(sortOrder)) {
                comparator = comparator.reversed();
            }
            authors = authors.stream()
                    .sorted(comparator)
                    .collect(Collectors.toList());

            // LOGGING ADDED
            logger.info("Список найденных авторов отсортирован по столбцу '{}' в порядке '{}'", sortColumn, sortOrder);
        }

        List<AuthorDTO> authorDTOs = authors.stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());

        // LOGGING ADDED
        logger.info("По запросу '{}' найдено {} авторов", query, authorDTOs.size());

        return new ResponseEntity<>(authorDTOs, HttpStatus.OK);
    }

    // Обновление автора
    @PutMapping("/{id}")
    public ResponseEntity<AuthorDTO> updateAuthor(@PathVariable int id, @Valid @RequestBody AuthorDTO authorDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на обновление автора с ID {}: {}", id, authorDTO);

        try {
            Author authorDetails = mapToEntity(authorDTO);
            Author updatedAuthor = authorService.updateAuthor(id, authorDetails);

            // LOGGING ADDED
            logger.info("Автор с ID {} успешно обновлён", id);

            AuthorDTO responseDTO = mapToDTO(updatedAuthor);
            return new ResponseEntity<>(responseDTO, HttpStatus.OK);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при обновлении автора с ID {}: {}", id, e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Удаление автора
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteAuthor(@PathVariable int id) {
        // LOGGING ADDED
        logger.info("Получен запрос на удаление автора с ID {}", id);

        try {
            authorService.deleteAuthor(id);

            // LOGGING ADDED
            logger.info("Автор с ID {} успешно удалён", id);

            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при удалении автора с ID {}: {}", id, e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    @DeleteMapping("/bulk-delete")
    public ResponseEntity<Void> deleteAuthors(
            @RequestBody List<Integer> authorIds,
            @RequestParam(name = "removeEverything", required = false, defaultValue = "false") boolean removeEverything
    ) {
        // LOGGING ADDED
        logger.info("Получен запрос на массовое удаление авторов. authorIds={}, removeEverything={}", authorIds, removeEverything);

        try {
            // Вызываем сервисный метод
            authorService.deleteAuthors(authorIds, removeEverything);

            // LOGGING ADDED
            logger.info("Массовое удаление авторов завершено. authorIds={}", authorIds);

            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при массовом удалении авторов: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    // Ручной маппинг DTO в сущность
    private Author mapToEntity(AuthorDTO dto) {
        Author author = new Author();
        author.setId(dto.getId());
        author.setFio(dto.getFio());
        author.setBirthDate(dto.getBirthDate());
        author.setCountry(dto.getCountry());
        author.setNickname(dto.getNickname());
        return author;
    }

    // Ручной маппинг сущности в DTO
    private AuthorDTO mapToDTO(Author author) {
        AuthorDTO dto = new AuthorDTO();
        dto.setId(author.getId());
        dto.setFio(author.getFio());
        dto.setBirthDate(author.getBirthDate());
        dto.setCountry(author.getCountry());
        dto.setNickname(author.getNickname());
        return dto;
    }

    /**
     * Возвращает компаратор для сортировки авторов по заданному столбцу.
     */
    private Comparator<Author> getComparator(String sortColumn) {
        switch (sortColumn.toLowerCase()) {
            case "fio":
                return Comparator.comparing(Author::getFio, Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER));
            case "birthdate":
                return Comparator.comparing(Author::getBirthDate, Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER));
            case "country":
                return Comparator.comparing(Author::getCountry, Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER));
            case "nickname":
                return Comparator.comparing(Author::getNickname, Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER));
            default:
                return Comparator.comparing(Author::getFio, Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER));
        }
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\controller\authorship\AuthorshipController.java =====

package org.application.bookstorage.controller.authorship;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.Authorship;
import org.application.bookstorage.dao.AuthorshipId;
import org.application.bookstorage.dao.Book;
import org.application.bookstorage.dto.AuthorshipDTO;
import org.application.bookstorage.service.authorship.AuthorshipService;
import org.application.bookstorage.service.author.AuthorService;
import org.application.bookstorage.service.book.BookService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.stream.Collectors;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/api/authorships")
@RequiredArgsConstructor
public class AuthorshipController {

    private final AuthorshipService authorshipService;
    private final BookService bookService;
    private final AuthorService authorService;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(AuthorshipController.class);

    // Создание авторства
    @PostMapping
    public ResponseEntity<AuthorshipDTO> createAuthorship(@Valid @RequestBody AuthorshipDTO authorshipDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на создание авторства: {}", authorshipDTO);

        try {
            // Проверка существования книги и автора
            Book book = bookService.getBookByIsbn(authorshipDTO.getBookIsbn())
                    .orElseThrow(() -> new RuntimeException("Книга не найдена: " + authorshipDTO.getBookIsbn()));
            org.application.bookstorage.dao.Author author = authorService.getAuthorById(authorshipDTO.getAuthorId())
                    .orElseThrow(() -> new RuntimeException("Автор не найден: " + authorshipDTO.getAuthorId()));

            // Создание объекта Authorship
            Authorship authorship = new Authorship();
            AuthorshipId id = new AuthorshipId(authorshipDTO.getBookIsbn(), authorshipDTO.getAuthorId());
            authorship.setId(id);
            authorship.setBook(book);
            authorship.setAuthor(author);

            Authorship createdAuthorship = authorshipService.createAuthorship(authorship);

            // LOGGING ADDED
            logger.info("Авторство успешно создано: {}", id);

            AuthorshipDTO responseDTO = mapToDTO(createdAuthorship);
            return new ResponseEntity<>(responseDTO, HttpStatus.CREATED);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при создании авторства: {}", e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    // Получение авторства по ключу
    @GetMapping("/{bookIsbn}/{authorId}")
    public ResponseEntity<AuthorshipDTO> getAuthorshipById(@PathVariable String bookIsbn, @PathVariable int authorId) {
        // LOGGING ADDED
        logger.info("Получен запрос на получение авторства по ключу: bookIsbn={}, authorId={}", bookIsbn, authorId);

        AuthorshipId id = new AuthorshipId(bookIsbn, authorId);
        return authorshipService.getAuthorshipById(id)
                .map(authorship -> {
                    // LOGGING ADDED
                    logger.info("Авторство найдено: {}", id);
                    return new ResponseEntity<>(mapToDTO(authorship), HttpStatus.OK);
                })
                .orElseGet(() -> {
                    // LOGGING ADDED
                    logger.warn("Авторство не найдено: {}", id);
                    return new ResponseEntity<>(HttpStatus.NOT_FOUND);
                });
    }

    // Получение всех авторств
    @GetMapping
    public ResponseEntity<List<AuthorshipDTO>> getAllAuthorships() {
        // LOGGING ADDED
        logger.info("Получен запрос на получение всех авторств");

        List<AuthorshipDTO> authorships = authorshipService.getAllAuthorships()
                .stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());

        // LOGGING ADDED
        logger.info("Возвращено {} авторств", authorships.size());

        return new ResponseEntity<>(authorships, HttpStatus.OK);
    }

    // Обновление авторства
    @PutMapping("/{bookIsbn}/{authorId}")
    public ResponseEntity<AuthorshipDTO> updateAuthorship(@PathVariable String bookIsbn, @PathVariable int authorId, @Valid @RequestBody AuthorshipDTO authorshipDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на обновление авторства bookIsbn={}, authorId={}. Новые данные: {}",
                bookIsbn, authorId, authorshipDTO);

        try {
            // Проверка существования новой книги и нового автора, если они изменяются
            Book newBook = bookService.getBookByIsbn(authorshipDTO.getBookIsbn())
                    .orElseThrow(() -> new RuntimeException("Книга не найдена: " + authorshipDTO.getBookIsbn()));
            org.application.bookstorage.dao.Author newAuthor = authorService.getAuthorById(authorshipDTO.getAuthorId())
                    .orElseThrow(() -> new RuntimeException("Автор не найден: " + authorshipDTO.getAuthorId()));

            // Создание объекта Authorship с новыми данными
            Authorship authorshipDetails = new Authorship();
            AuthorshipId newId = new AuthorshipId(authorshipDTO.getBookIsbn(), authorshipDTO.getAuthorId());
            authorshipDetails.setId(newId);
            authorshipDetails.setBook(newBook);
            authorshipDetails.setAuthor(newAuthor);

            // Обновление авторства
            Authorship updatedAuthorship = authorshipService.updateAuthorship(new AuthorshipId(bookIsbn, authorId), authorshipDetails);

            // LOGGING ADDED
            logger.info("Авторство успешно обновлено: старый ключ={}, новый ключ={}",
                    new AuthorshipId(bookIsbn, authorId), newId);

            AuthorshipDTO responseDTO = mapToDTO(updatedAuthorship);
            return new ResponseEntity<>(responseDTO, HttpStatus.OK);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при обновлении авторства: {}", e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Удаление авторства
    @DeleteMapping("/{bookIsbn}/{authorId}")
    public ResponseEntity<Void> deleteAuthorship(@PathVariable String bookIsbn, @PathVariable int authorId) {
        // LOGGING ADDED
        logger.info("Получен запрос на удаление авторства: bookIsbn={}, authorId={}", bookIsbn, authorId);

        try {
            AuthorshipId id = new AuthorshipId(bookIsbn, authorId);
            authorshipService.deleteAuthorship(id);

            // LOGGING ADDED
            logger.info("Авторство удалено: {}", id);

            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при удалении авторства: {}", e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Ручной маппинг сущности в DTO
    private AuthorshipDTO mapToDTO(Authorship authorship) {
        AuthorshipDTO dto = new AuthorshipDTO();
        dto.setBookIsbn(authorship.getBook().getIsbn());
        dto.setAuthorId(authorship.getAuthor().getId());
        return dto;
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\controller\book\BookController.java =====

package org.application.bookstorage.controller.book;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.*;
import org.application.bookstorage.dto.BookDTO;
import org.application.bookstorage.dto.AuthorDTO;
import org.application.bookstorage.service.author.AuthorService;
import org.application.bookstorage.service.authorship.AuthorshipService;
import org.application.bookstorage.service.book.BookService;
import org.application.bookstorage.service.bookstyles.BookStylesService;
import org.application.bookstorage.service.publishingcompany.PublishingCompanyService;
import org.application.bookstorage.service.styles.StylesService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/api/books")
@RequiredArgsConstructor
public class BookController {

    private final BookService bookService;
    private final PublishingCompanyService publishingCompanyService;
    private final AuthorService authorService;
    private final AuthorshipService authorshipService;
    private final StylesService stylesService;
    private final BookStylesService bookStylesService;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(BookController.class);

    /**
     * Эндпоинт для массового удаления книг.
     * Метод: DELETE
     * URL: /api/books/bulk-delete
     * Тело запроса: список ISBN книг для удаления
     */
    @DeleteMapping("/bulk-delete")
    public ResponseEntity<Void> deleteBooks(@RequestBody List<String> isbns) {
        // LOGGING ADDED
        logger.info("Получен запрос на массовое удаление книг: {}", isbns);

        try {
            bookService.deleteBooks(isbns);

            // LOGGING ADDED
            logger.info("Массовое удаление книг успешно завершено.");

            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при массовом удалении книг: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    // Создание книги
    @PostMapping
    public ResponseEntity<BookDTO> createBook(@Valid @RequestBody BookDTO bookDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на создание книги: {}", bookDTO);

        try {
            // Получение или создание издательства
            PublishingCompany publishingCompany = getOrCreatePublishingCompany(bookDTO.getPublishingCompany());

            // Создание книги
            Book book = new Book();
            book.setIsbn(bookDTO.getIsbn());
            book.setName(bookDTO.getName());
            book.setPublicationYear(bookDTO.getPublicationYear());
            book.setAgeLimit(bookDTO.getAgeLimit());
            book.setPublishingCompany(publishingCompany);
            book.setPageCount(bookDTO.getPageCount());
            book.setLanguage(bookDTO.getLanguage());
            book.setCost(bookDTO.getCost());
            book.setCountOfBooks(bookDTO.getCountOfBooks());

            // Инициализация множеств, если необходимо
            if (book.getAuthorships() == null) {
                book.setAuthorships(new java.util.HashSet<>());
            }
            if (book.getBookStyles() == null) {
                book.setBookStyles(new java.util.HashSet<>());
            }

            // Обработка авторов
            List<Authorship> authorships = bookDTO.getAuthors().stream().map(authorDTO -> {
                Author author;
                if (authorDTO.getId() != null) { // Проверка, предоставлен ли ID
                    author = authorService.getAuthorById(authorDTO.getId())
                            .orElseThrow(() -> new RuntimeException("Автор не найден с ID: " + authorDTO.getId()));
                } else { // Создание нового автора
                    author = new Author();
                    author.setFio(authorDTO.getFio());
                    author.setBirthDate(authorDTO.getBirthDate());
                    author.setCountry(authorDTO.getCountry());
                    author.setNickname(authorDTO.getNickname());
                    author = authorService.createAuthor(author);
                }
                Authorship authorship = new Authorship();
                authorship.setBook(book);
                authorship.setAuthor(author);
                authorship.setId(new org.application.bookstorage.dao.AuthorshipId(book.getIsbn(), author.getId()));
                return authorship;
            }).collect(Collectors.toList());

            book.getAuthorships().addAll(authorships);

            // Обработка жанров
            List<String> genres = bookDTO.getGenres();
            for (String genreName : genres) {
                Styles style = stylesService.getStyleByName(genreName)
                        .orElseGet(() -> stylesService.createStyle(new Styles(null, genreName, null)));
                BookStyles bookStyle = new BookStyles();
                bookStyle.setBook(book);
                bookStyle.setStyleEntity(style);
                bookStyle.setId(new BookStylesId(book.getIsbn(), style.getId()));
                book.getBookStyles().add(bookStyle);
            }

            // Сохранение книги
            Book createdBook = bookService.createBook(book);

            // LOGGING ADDED
            logger.info("Книга успешно создана: ISBN={}", createdBook.getIsbn());

            // Преобразование в DTO
            BookDTO responseDTO = mapToDTO(createdBook);
            return new ResponseEntity<>(responseDTO, HttpStatus.CREATED);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при создании книги: {}", e.getMessage(), e);
            e.printStackTrace();
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    // Метод для получения или создания издательства
    private PublishingCompany getOrCreatePublishingCompany(String companyName) {
        if (companyName == null || companyName.trim().isEmpty()) {
            throw new RuntimeException("Название издательства не может быть пустым");
        }
        Optional<PublishingCompany> optionalCompany = publishingCompanyService.getPublishingCompanyByName(companyName.trim());
        return optionalCompany.orElseGet(() -> {
            PublishingCompany newCompany = new PublishingCompany();
            newCompany.setName(companyName.trim());
            // Устанавливаем другие поля издательства, если необходимо

            // LOGGING ADDED
            logger.info("Издательство не найдено, создаём новое: {}", newCompany.getName());

            return publishingCompanyService.createPublishingCompany(newCompany);
        });
    }

    // Получение книги по ISBN
    @GetMapping("/{isbn}")
    public ResponseEntity<BookDTO> getBookByIsbn(@PathVariable String isbn) {
        // LOGGING ADDED
        logger.info("Получен запрос на получение книги по ISBN: {}", isbn);

        return bookService.getBookByIsbn(isbn)
                .map(book -> {
                    // LOGGING ADDED
                    logger.info("Книга найдена: ISBN={}", book.getIsbn());
                    return new ResponseEntity<>(mapToDTO(book), HttpStatus.OK);
                })
                .orElseGet(() -> {
                    // LOGGING ADDED
                    logger.warn("Книга с ISBN {} не найдена", isbn);
                    return new ResponseEntity<>(HttpStatus.NOT_FOUND);
                });
    }

    // Получение всех книг
    @GetMapping
    public ResponseEntity<List<BookDTO>> getAllBooks(
            @RequestParam(required = false) String search,
            @RequestParam(required = false, name = "sort_column") String sortColumn,
            @RequestParam(required = false, name = "sort_order") String sortOrder) {
        // LOGGING ADDED
        logger.info("Получен запрос на получение всех книг. search={}, sort_column={}, sort_order={}",
                search, sortColumn, sortOrder);

        try {
            List<Book> books = bookService.getAllBooks(search, sortColumn, sortOrder);
            List<BookDTO> bookDTOs = books.stream().map(this::mapToDTO).collect(Collectors.toList());

            // LOGGING ADDED
            logger.info("Поиск завершён. Найдено {} книг.", bookDTOs.size());

            return new ResponseEntity<>(bookDTOs, HttpStatus.OK);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при получении списка книг: {}", e.getMessage(), e);
            e.printStackTrace();
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    // Обновление книги
    @PutMapping("/{isbn}")
    public ResponseEntity<BookDTO> updateBook(@PathVariable String isbn, @Valid @RequestBody BookDTO bookDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на обновление книги ISBN={}. Новые данные: {}", isbn, bookDTO);

        try {
            // Получение или создание издательства
            PublishingCompany publishingCompany = getOrCreatePublishingCompany(bookDTO.getPublishingCompany());

            // Получаем существующую книгу
            Book existingBook = bookService.getBookByIsbn(isbn)
                    .orElseThrow(() -> new RuntimeException("Книга не найдена с ISBN " + isbn));

            // Обновляем основные поля
            existingBook.setName(bookDTO.getName());
            existingBook.setPublicationYear(bookDTO.getPublicationYear());
            existingBook.setAgeLimit(bookDTO.getAgeLimit());
            existingBook.setPublishingCompany(publishingCompany);
            existingBook.setPageCount(bookDTO.getPageCount());
            existingBook.setLanguage(bookDTO.getLanguage());
            existingBook.setCost(bookDTO.getCost());
            existingBook.setCountOfBooks(bookDTO.getCountOfBooks());

            // 1. Обновляем авторов:
            existingBook.getAuthorships().clear();
            List<Authorship> newAuthorships = bookDTO.getAuthors().stream().map(authorDTO -> {
                Author author;
                if (authorDTO.getId() != null) {
                    author = authorService.getAuthorById(authorDTO.getId())
                            .orElseThrow(() -> new RuntimeException("Автор не найден с ID: " + authorDTO.getId()));
                } else {
                    author = new Author();
                    author.setFio(authorDTO.getFio());
                    author.setBirthDate(authorDTO.getBirthDate());
                    author.setCountry(authorDTO.getCountry());
                    author.setNickname(authorDTO.getNickname());
                    author = authorService.createAuthor(author);
                }
                Authorship authorship = new Authorship();
                authorship.setId(new AuthorshipId(existingBook.getIsbn(), author.getId()));
                authorship.setBook(existingBook);
                authorship.setAuthor(author);
                return authorship;
            }).collect(Collectors.toList());
            existingBook.getAuthorships().addAll(newAuthorships);

            // 2. Обновляем жанры (BookStyles):
            existingBook.getBookStyles().clear();
            List<String> genres = bookDTO.getGenres();
            for (String genreName : genres) {
                Styles style = stylesService.getStyleByName(genreName)
                        .orElseGet(() -> stylesService.createStyle(new Styles(null, genreName, null)));
                BookStyles bookStyle = new BookStyles();
                bookStyle.setId(new BookStylesId(existingBook.getIsbn(), style.getId()));
                bookStyle.setBook(existingBook);
                bookStyle.setStyleEntity(style);
                existingBook.getBookStyles().add(bookStyle);
            }

            // Сохраняем обновлённую книгу
            Book updatedBook = bookService.updateBook(isbn, existingBook);

            // LOGGING ADDED
            logger.info("Книга с ISBN {} успешно обновлена", isbn);

            BookDTO responseDTO = mapToDTO(updatedBook);
            return new ResponseEntity<>(responseDTO, HttpStatus.OK);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при обновлении книги ISBN {}: {}", isbn, e.getMessage(), e);
            e.printStackTrace();
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Удаление книги
    @DeleteMapping("/{isbn}")
    public ResponseEntity<Void> deleteBook(@PathVariable String isbn) {
        // LOGGING ADDED
        logger.info("Получен запрос на удаление книги ISBN={}", isbn);

        try {
            bookService.deleteBook(isbn);

            // LOGGING ADDED
            logger.info("Книга с ISBN {} успешно удалена", isbn);

            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при удалении книги ISBN {}: {}", isbn, e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Ручной маппинг DTO в сущность
    private Book mapToEntity(BookDTO dto) {
        Book book = new Book();
        book.setIsbn(dto.getIsbn());
        book.setName(dto.getName());
        book.setPublicationYear(dto.getPublicationYear());
        book.setAgeLimit(dto.getAgeLimit());
        book.setPageCount(dto.getPageCount());
        book.setLanguage(dto.getLanguage());
        book.setCost(dto.getCost());
        book.setCountOfBooks(dto.getCountOfBooks());
        if (book.getAuthorships() == null) {
            book.setAuthorships(new java.util.HashSet<>());
        }
        if (book.getBookStyles() == null) {
            book.setBookStyles(new java.util.HashSet<>());
        }
        return book;
    }

    // Ручной маппинг сущности в DTO
    private BookDTO mapToDTO(Book book) {
        BookDTO dto = new BookDTO();
        dto.setIsbn(book.getIsbn());
        dto.setName(book.getName());
        dto.setPublicationYear(book.getPublicationYear());
        dto.setAgeLimit(book.getAgeLimit());
        dto.setPublishingCompany(book.getPublishingCompany().getName());
        dto.setPageCount(book.getPageCount());
        dto.setLanguage(book.getLanguage());
        dto.setCost(book.getCost());
        dto.setCountOfBooks(book.getCountOfBooks());

        List<AuthorDTO> authors = book.getAuthorships().stream()
                .map(authorship -> {
                    AuthorDTO authorDTO = new AuthorDTO();
                    authorDTO.setId(authorship.getAuthor().getId());
                    authorDTO.setFio(authorship.getAuthor().getFio());
                    authorDTO.setBirthDate(authorship.getAuthor().getBirthDate());
                    authorDTO.setCountry(authorship.getAuthor().getCountry());
                    authorDTO.setNickname(authorship.getAuthor().getNickname());
                    return authorDTO;
                }).collect(Collectors.toList());

        dto.setAuthors(authors);

        List<String> genres = book.getBookStyles().stream()
                .map(bookStyle -> bookStyle.getStyleEntity().getName())
                .collect(Collectors.toList());

        dto.setGenres(genres);

        return dto;
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\controller\bookstyles\BookStylesController.java =====

package org.application.bookstorage.controller.bookstyles;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.BookStyles;
import org.application.bookstorage.dao.BookStylesId;
import org.application.bookstorage.dto.BookStylesDTO;
import org.application.bookstorage.service.book.BookService;
import org.application.bookstorage.service.bookstyles.BookStylesService;
import org.application.bookstorage.service.styles.StylesService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.stream.Collectors;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/api/book-styles")
@RequiredArgsConstructor
public class BookStylesController {

    private final BookStylesService bookStylesService;
    private final BookService bookService;
    private final StylesService stylesService;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(BookStylesController.class);

    // Создание связи книги со стилем
    @PostMapping
    public ResponseEntity<BookStylesDTO> createBookStyles(@Valid @RequestBody BookStylesDTO bookStylesDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на создание связи книги со стилем: {}", bookStylesDTO);

        try {
            BookStyles bookStyles = mapToEntity(bookStylesDTO);
            BookStylesId id = new BookStylesId(bookStylesDTO.getBookIsbn(), bookStylesDTO.getStyleId());

            // Проверка существования книги
            bookStyles.setBook(bookService.getBookByIsbn(bookStylesDTO.getBookIsbn())
                    .orElseThrow(() -> new RuntimeException("Книга не найдена: " + bookStylesDTO.getBookIsbn())));

            // Проверка существования стиля
            bookStyles.setStyleEntity(stylesService.getStyleById(bookStylesDTO.getStyleId())
                    .orElseThrow(() -> new RuntimeException("Стиль не найден: " + bookStylesDTO.getStyleId())));

            // Создание связи
            BookStyles createdBookStyles = bookStylesService.createBookStyles(bookStyles);

            // LOGGING ADDED
            logger.info("Связь книги со стилем успешно создана: {}", id);

            BookStylesDTO responseDTO = mapToDTO(createdBookStyles);
            return new ResponseEntity<>(responseDTO, HttpStatus.CREATED);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при создании связи книги со стилем: {}", e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    // Получение связи книги со стилем по ключу
    @GetMapping("/{bookIsbn}/{styleId}")
    public ResponseEntity<BookStylesDTO> getBookStylesById(@PathVariable String bookIsbn, @PathVariable Long styleId) {
        // LOGGING ADDED
        logger.info("Получен запрос на получение связи книги со стилем: bookIsbn={}, styleId={}", bookIsbn, styleId);

        BookStylesId id = new BookStylesId(bookIsbn, styleId);
        return bookStylesService.getBookStylesById(id)
                .map(bookStyles -> {
                    // LOGGING ADDED
                    logger.info("Связь книги со стилем найдена: {}", id);
                    return new ResponseEntity<>(mapToDTO(bookStyles), HttpStatus.OK);
                })
                .orElseGet(() -> {
                    // LOGGING ADDED
                    logger.warn("Связь книги со стилем не найдена: {}", id);
                    return new ResponseEntity<>(HttpStatus.NOT_FOUND);
                });
    }

    // Получение всех связей книг со стилями
    @GetMapping
    public ResponseEntity<List<BookStylesDTO>> getAllBookStyles() {
        // LOGGING ADDED
        logger.info("Получен запрос на получение всех связей книги со стилями");

        List<BookStylesDTO> bookStyles = bookStylesService.getAllBookStyles()
                .stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());

        // LOGGING ADDED
        logger.info("Возвращено {} связей книги со стилями", bookStyles.size());

        return new ResponseEntity<>(bookStyles, HttpStatus.OK);
    }

    // Обновление связи книги со стилем
    @PutMapping("/{bookIsbn}/{styleId}")
    public ResponseEntity<BookStylesDTO> updateBookStyles(@PathVariable String bookIsbn, @PathVariable Long styleId, @Valid @RequestBody BookStylesDTO bookStylesDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на обновление связи книги со стилем: bookIsbn={}, styleId={}. Новые данные: {}",
                bookIsbn, styleId, bookStylesDTO);

        try {
            BookStylesId oldId = new BookStylesId(bookIsbn, styleId);
            BookStyles bookStyles = new BookStyles();
            bookStyles.setId(new BookStylesId(bookStylesDTO.getBookIsbn(), bookStylesDTO.getStyleId()));

            // Проверка существования новой книги и нового стиля
            bookStyles.setBook(bookService.getBookByIsbn(bookStylesDTO.getBookIsbn())
                    .orElseThrow(() -> new RuntimeException("Книга не найдена: " + bookStylesDTO.getBookIsbn())));
            bookStyles.setStyleEntity(stylesService.getStyleById(bookStylesDTO.getStyleId())
                    .orElseThrow(() -> new RuntimeException("Стиль не найден: " + bookStylesDTO.getStyleId())));

            // Обновление связи
            BookStyles updatedBookStyles = bookStylesService.updateBookStyles(oldId, bookStyles);

            // LOGGING ADDED
            logger.info("Связь книги со стилем успешно обновлена: старый ключ={}, новый ключ={}",
                    oldId, updatedBookStyles.getId());

            BookStylesDTO responseDTO = mapToDTO(updatedBookStyles);
            return new ResponseEntity<>(responseDTO, HttpStatus.OK);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при обновлении связи книги со стилем: {}", e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Удаление связи книги со стилем
    @DeleteMapping("/{bookIsbn}/{styleId}")
    public ResponseEntity<Void> deleteBookStyles(@PathVariable String bookIsbn, @PathVariable Long styleId) {
        // LOGGING ADDED
        logger.info("Получен запрос на удаление связи книги со стилем: bookIsbn={}, styleId={}", bookIsbn, styleId);

        try {
            BookStylesId id = new BookStylesId(bookIsbn, styleId);
            bookStylesService.deleteBookStyles(id);

            // LOGGING ADDED
            logger.info("Связь книги со стилем удалена: {}", id);

            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при удалении связи книги со стилем: {}", e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Ручной маппинг сущности в DTO
    private BookStylesDTO mapToDTO(BookStyles bookStyles) {
        BookStylesDTO dto = new BookStylesDTO();
        dto.setBookIsbn(bookStyles.getBook().getIsbn());
        dto.setStyleId(bookStyles.getStyleEntity().getId());
        return dto;
    }

    // Ручной маппинг DTO в сущность
    private BookStyles mapToEntity(BookStylesDTO dto) {
        BookStyles bookStyles = new BookStyles();
        BookStylesId id = new BookStylesId(dto.getBookIsbn(), dto.getStyleId());
        bookStyles.setId(id);
        return bookStyles;
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\controller\csv\CsvController.java =====

package org.application.bookstorage.controller.csv;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.service.csv.CsvService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;

@RestController
@RequestMapping("/api/csv")
@RequiredArgsConstructor
public class CsvController {

    private static final Logger logger = LoggerFactory.getLogger(CsvController.class);

    private final CsvService csvService;

    /**
     * Эндпоинт для экспорта данных в CSV файлы.
     * Метод: POST
     * URL: /api/csv/export
     */
    @PostMapping("/export")
    public ResponseEntity<String> exportData() {
        // LOGGING ADDED
        logger.info("Получен запрос на экспорт данных в CSV");

        try {
            csvService.exportData();

            // LOGGING ADDED
            logger.info("Экспорт данных в CSV успешно завершён.");

            return ResponseEntity.ok("Данные успешно экспортированы в CSV файлы.");
        } catch (IOException e) {
            logger.error("Ошибка при экспорте данных", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Ошибка при экспорте данных: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Непредвиденная ошибка при экспорте данных", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Непредвиденная ошибка при экспорте данных: " + e.getMessage());
        }
    }

    /**
     * Эндпоинт для импорта данных из CSV файлов.
     * Метод: POST
     * URL: /api/csv/import
     */
    @PostMapping("/import")
    public ResponseEntity<String> importData() {
        // LOGGING ADDED
        logger.info("Получен запрос на импорт данных из CSV");

        try {
            csvService.importData();

            // LOGGING ADDED
            logger.info("Импорт данных из CSV успешно завершён.");

            return ResponseEntity.ok("Данные успешно импортированы из CSV файлов.");
        } catch (IOException e) {
            logger.error("Ошибка при импорте данных", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Ошибка при импорте данных: " + e.getMessage());
        } catch (Exception e) {
            logger.error("Непредвиденная ошибка при импорте данных", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Непредвиденная ошибка при импорте данных: " + e.getMessage());
        }
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\controller\publishingcompany\PublishingCompanyController.java =====

package org.application.bookstorage.controller.publishingcompany;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.PublishingCompany;
import org.application.bookstorage.dto.PublishingCompanyDTO;
import org.application.bookstorage.service.publishingcompany.PublishingCompanyService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.stream.Collectors;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/api/publishing-companies")
@RequiredArgsConstructor
public class PublishingCompanyController {

    private final PublishingCompanyService publishingCompanyService;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(PublishingCompanyController.class);

    // Создание издательства
    @PostMapping
    public ResponseEntity<PublishingCompanyDTO> createPublishingCompany(@Valid @RequestBody PublishingCompanyDTO companyDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на создание издательства: {}", companyDTO);

        try {
            PublishingCompany company = mapToEntity(companyDTO);
            PublishingCompany createdCompany = publishingCompanyService.createPublishingCompany(company);

            // LOGGING ADDED
            logger.info("Издательство успешно создано: {}", createdCompany.getName());

            PublishingCompanyDTO responseDTO = mapToDTO(createdCompany);
            return new ResponseEntity<>(responseDTO, HttpStatus.CREATED);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при создании издательства: {}", e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    // Получение издательства по имени
    @GetMapping("/{name}")
    public ResponseEntity<PublishingCompanyDTO> getPublishingCompanyByName(@PathVariable String name) {
        // LOGGING ADDED
        logger.info("Получен запрос на получение издательства по имени: {}", name);

        return publishingCompanyService.getPublishingCompanyByName(name)
                .map(company -> {
                    // LOGGING ADDED
                    logger.info("Издательство найдено: {}", company.getName());
                    return new ResponseEntity<>(mapToDTO(company), HttpStatus.OK);
                })
                .orElseGet(() -> {
                    // LOGGING ADDED
                    logger.warn("Издательство с именем '{}' не найдено", name);
                    return new ResponseEntity<>(HttpStatus.NOT_FOUND);
                });
    }

    // Получение всех издательств
    @GetMapping
    public ResponseEntity<List<PublishingCompanyDTO>> getAllPublishingCompanies() {
        // LOGGING ADDED
        logger.info("Получен запрос на получение всех издательств");

        List<PublishingCompanyDTO> companies = publishingCompanyService.getAllPublishingCompanies()
                .stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());

        // LOGGING ADDED
        logger.info("Возвращено {} издательств", companies.size());

        return new ResponseEntity<>(companies, HttpStatus.OK);
    }

    // Обновление издательства
    @PutMapping("/{originalName}")
    public ResponseEntity<PublishingCompanyDTO> updatePublishingCompany(
            @PathVariable String originalName,
            @Valid @RequestBody PublishingCompanyDTO companyDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на обновление издательства. Оригинальное имя={}, новые данные={}",
                originalName, companyDTO);

        try {
            PublishingCompany companyDetails = mapToEntity(companyDTO);
            PublishingCompany updatedCompany = publishingCompanyService.updatePublishingCompany(originalName, companyDetails);

            // LOGGING ADDED
            logger.info("Издательство '{}' успешно обновлено. Текущее имя='{}'",
                    originalName, updatedCompany.getName());

            PublishingCompanyDTO responseDTO = mapToDTO(updatedCompany);
            return new ResponseEntity<>(responseDTO, HttpStatus.OK);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при обновлении издательства '{}': {}", originalName, e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Удаление издательств (bulk-delete)
    @DeleteMapping("/bulk-delete")
    public ResponseEntity<Void> deletePublishingCompanies(@RequestBody List<String> names) {
        // LOGGING ADDED
        logger.info("Получен запрос на массовое удаление издательств: {}", names);

        try {
            publishingCompanyService.deletePublishingCompanies(names);

            // LOGGING ADDED
            logger.info("Массовое удаление издательств завершено.");

            return ResponseEntity.noContent().build();
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при массовом удалении издательств: {}", e.getMessage(), e);
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }
    }

    // Эндпоинт для поиска издательств по части названия
    @GetMapping("/search")
    public ResponseEntity<List<PublishingCompany>> searchPublishingCompanies(@RequestParam("q") String query) {
        // LOGGING ADDED
        logger.info("Получен запрос на поиск издательств по части названия: {}", query);

        List<PublishingCompany> companies = publishingCompanyService.searchPublishingCompaniesByName(query);

        // LOGGING ADDED
        logger.info("Поиск завершён. Найдено {} совпадений", companies.size());

        return ResponseEntity.ok(companies);
    }

    // Ручной маппинг DTO в сущность
    private PublishingCompany mapToEntity(PublishingCompanyDTO dto) {
        PublishingCompany company = new PublishingCompany();
        company.setName(dto.getName());
        company.setEstablishmentYear(dto.getEstablishmentYear());
        company.setContactInfo(dto.getContactInfo());
        company.setCity(dto.getCity());
        return company;
    }

    // Ручной маппинг сущности в DTO
    private PublishingCompanyDTO mapToDTO(PublishingCompany company) {
        PublishingCompanyDTO dto = new PublishingCompanyDTO();
        dto.setName(company.getName());
        dto.setEstablishmentYear(company.getEstablishmentYear());
        dto.setContactInfo(company.getContactInfo());
        dto.setCity(company.getCity());
        return dto;
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\controller\styles\StylesController.java =====

package org.application.bookstorage.controller.styles;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.Styles;
import org.application.bookstorage.dto.StylesDTO;
import org.application.bookstorage.service.styles.StylesService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.List;
import java.util.stream.Collectors;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
@RequestMapping("/api/styles")
@RequiredArgsConstructor
public class StylesController {

    private final StylesService stylesService;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(StylesController.class);

    // Создание стиля
    @PostMapping
    public ResponseEntity<StylesDTO> createStyle(@Valid @RequestBody StylesDTO styleDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на создание стиля: {}", styleDTO);

        try {
            Styles style = mapToEntity(styleDTO);
            Styles createdStyle = stylesService.createStyle(style);

            // LOGGING ADDED
            logger.info("Стиль успешно создан: {}", createdStyle.getId());

            StylesDTO responseDTO = mapToDTO(createdStyle);
            return new ResponseEntity<>(responseDTO, HttpStatus.CREATED);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при создании стиля: {}", e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
        }
    }

    // Получение стиля по ID
    @GetMapping("/{id}")
    public ResponseEntity<StylesDTO> getStyleById(@PathVariable Long id) {
        // LOGGING ADDED
        logger.info("Получен запрос на получение стиля по ID: {}", id);

        return stylesService.getStyleById(id)
                .map(style -> {
                    // LOGGING ADDED
                    logger.info("Стиль найден: {}", style.getId());
                    return new ResponseEntity<>(mapToDTO(style), HttpStatus.OK);
                })
                .orElseGet(() -> {
                    // LOGGING ADDED
                    logger.warn("Стиль с ID {} не найден", id);
                    return new ResponseEntity<>(HttpStatus.NOT_FOUND);
                });
    }

    // Получение всех стилей
    @GetMapping
    public ResponseEntity<List<StylesDTO>> getAllStyles() {
        // LOGGING ADDED
        logger.info("Получен запрос на получение всех стилей");

        List<StylesDTO> styles = stylesService.getAllStyles()
                .stream()
                .map(this::mapToDTO)
                .collect(Collectors.toList());

        // LOGGING ADDED
        logger.info("Возвращено {} стилей", styles.size());

        return new ResponseEntity<>(styles, HttpStatus.OK);
    }

    // Обновление стиля
    @PutMapping("/{id}")
    public ResponseEntity<StylesDTO> updateStyle(@PathVariable Long id, @Valid @RequestBody StylesDTO styleDTO) {
        // LOGGING ADDED
        logger.info("Получен запрос на обновление стиля с ID {}. Новые данные: {}", id, styleDTO);

        try {
            Styles styleDetails = mapToEntity(styleDTO);
            Styles updatedStyle = stylesService.updateStyle(id, styleDetails);

            // LOGGING ADDED
            logger.info("Стиль с ID {} успешно обновлён", id);

            StylesDTO responseDTO = mapToDTO(updatedStyle);
            return new ResponseEntity<>(responseDTO, HttpStatus.OK);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при обновлении стиля с ID {}: {}", id, e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Удаление стиля
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteStyle(@PathVariable Long id) {
        // LOGGING ADDED
        logger.info("Получен запрос на удаление стиля с ID {}", id);

        try {
            stylesService.deleteStyle(id);

            // LOGGING ADDED
            logger.info("Стиль с ID {} успешно удалён", id);

            return new ResponseEntity<>(HttpStatus.NO_CONTENT);
        } catch (RuntimeException e) {
            // LOGGING ADDED
            logger.error("Ошибка при удалении стиля с ID {}: {}", id, e.getMessage(), e);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        }
    }

    // Эндпоинт для поиска стилей по части названия
    @GetMapping("/search")
    public ResponseEntity<List<StylesDTO>> searchStyles(@RequestParam("q") String query) {
        // LOGGING ADDED
        logger.info("Получен запрос на поиск стилей по части названия: {}", query);

        List<Styles> styles = stylesService.searchStylesByName(query);
        List<StylesDTO> stylesDTO = styles.stream().map(this::mapToDTO).collect(Collectors.toList());

        // LOGGING ADDED
        logger.info("По запросу '{}' найдено {} стилей", query, stylesDTO.size());

        return new ResponseEntity<>(stylesDTO, HttpStatus.OK);
    }

    // Ручной маппинг DTO в сущность
    private Styles mapToEntity(StylesDTO dto) {
        Styles style = new Styles();
        style.setId(dto.getId());
        style.setName(dto.getName());
        return style;
    }

    // Ручной маппинг сущности в DTO
    private StylesDTO mapToDTO(Styles style) {
        StylesDTO dto = new StylesDTO();
        dto.setId(style.getId());
        dto.setName(style.getName());
        return dto;
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\dao\Author.java =====

package org.application.bookstorage.dao;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.Set;

@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "authors")
public class Author {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Автоинкремент
    @Column(name = "id")
    private Integer id;

    @Column(name = "fio")
    private String fio;

    @Column(name = "birth_date")
    private String birthDate;

    @Column(name = "country")
    private String country;

    @Column(name = "nickname")
    private String nickname;

    @OneToMany(mappedBy = "author", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Authorship> authorships;

}


===== bookstorage/src/main/java/org/application/bookstorage\dao\Authorship.java =====

package org.application.bookstorage.dao;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "authorships")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Authorship {

    @EmbeddedId
    private AuthorshipId id;

    @ManyToOne
    @MapsId("bookIsbn")
    @JoinColumn(name = "book_isbn")
    private Book book;

    @ManyToOne
    @MapsId("authorId")
    @JoinColumn(name = "author_id")
    private Author author;
}


===== bookstorage/src/main/java/org/application/bookstorage\dao\AuthorshipId.java =====

package org.application.bookstorage.dao;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthorshipId implements Serializable {

    private String bookIsbn;
    private int authorId;


}

===== bookstorage/src/main/java/org/application/bookstorage\dao\Book.java =====

package org.application.bookstorage.dao;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.Set;


@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table (name = "books")
public class Book {
     @Id
     @Column(name = "isbn")
     private String isbn;

     @Column(name = "name")
     private String name;

     @Column(name = "publication_year")
     private LocalDate publicationYear;

     @Column(name = "age_limit")
     private float ageLimit; // Изменено на float для соответствия SQL типу real

     @ManyToOne
     @JoinColumn(name = "publishing_company")
     @JsonManagedReference
     private PublishingCompany publishingCompany;

     @Column(name = "page_count")
     private int pageCount;

     @Column(name = "language")
     private String language;

     @Column(name = "cost")
     private BigDecimal cost;

     @Column(name = "count_of_books")
     private int countOfBooks;

     @OneToMany(mappedBy = "book", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
     private Set<Authorship> authorships;

     @OneToMany(mappedBy = "book", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
     private Set<BookStyles> bookStyles;

}


===== bookstorage/src/main/java/org/application/bookstorage\dao\BookStyles.java =====

package org.application.bookstorage.dao;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "book_styles")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BookStyles {

    @EmbeddedId
    private BookStylesId id;

    @ManyToOne
    @MapsId("bookIsbn")
    @JoinColumn(name = "book_isbn")
    private Book book;

    @ManyToOne
    @MapsId("style")
    @JoinColumn(name = "style")
    private Styles styleEntity;
}



===== bookstorage/src/main/java/org/application/bookstorage\dao\BookStylesId.java =====

package org.application.bookstorage.dao;

import jakarta.persistence.Embeddable;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Embeddable
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BookStylesId implements Serializable {

    private String bookIsbn;
    private Long style;
}


===== bookstorage/src/main/java/org/application/bookstorage\dao\PublishingCompany.java =====

package org.application.bookstorage.dao;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;
import java.util.Set;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "publishing_companies")
public class PublishingCompany {

    @Id
    @Column(name = "name")
    private String name;

    @Column(name = "establishment_year")
    private LocalDate establishmentYear;

    @Column(name = "contact_info")
    private String contactInfo;

    @Column(name = "city")
    private String city;

    @OneToMany(mappedBy = "publishingCompany", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    @JsonBackReference
    private Set<Book> books;
}



===== bookstorage/src/main/java/org/application/bookstorage\dao\Styles.java =====

package org.application.bookstorage.dao;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "styles")
public class Styles {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "name")
    private String name;

    @OneToMany(mappedBy = "styleEntity", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private List<BookStyles> bookStyles;
}



===== bookstorage/src/main/java/org/application/bookstorage\dto\AuthorDTO.java =====

package org.application.bookstorage.dto;

import lombok.Data;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

@Data
public class AuthorDTO {
//    @NotNull(message = "ID автора не может быть null")
    private Integer id;

    @NotBlank(message = "ФИО автора не может быть пустым")
    private String fio;

    private String birthDate;

    private String country;

    private String nickname;
}




===== bookstorage/src/main/java/org/application/bookstorage\dto\AuthorshipDTO.java =====

package org.application.bookstorage.dto;

import lombok.Data;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

@Data
public class AuthorshipDTO {
    @NotBlank(message = "ISBN книги не может быть пустым")
    private String bookIsbn;

    //@NotNull(message = "ID автора не может быть null")
    private Integer authorId;
}


===== bookstorage/src/main/java/org/application/bookstorage\dto\BookDTO.java =====

package org.application.bookstorage.dto;

import lombok.Data;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;

@Data
public class BookDTO {
    @NotBlank(message = "ISBN книги не может быть пустым")
    private String isbn;

    @NotBlank(message = "Название книги не может быть пустым")
    private String name;

    private LocalDate publicationYear;

    private float ageLimit;

    @NotBlank(message = "Название издательства не может быть пустым")
    private String publishingCompany;

    private int pageCount;

    private String language;

    private BigDecimal cost;

    private int countOfBooks;

    private List<AuthorDTO> authors;

    private List<String> genres;
}


===== bookstorage/src/main/java/org/application/bookstorage\dto\BookStylesDTO.java =====

package org.application.bookstorage.dto;

import lombok.Data;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

@Data
public class BookStylesDTO {
    @NotBlank(message = "ISBN книги не может быть пустым")
    private String bookIsbn;

    @NotNull(message = "ID стиля не может быть null")
    private Long styleId;
}


===== bookstorage/src/main/java/org/application/bookstorage\dto\PublishingCompanyDTO.java =====

package org.application.bookstorage.dto;

import lombok.Data;

import jakarta.validation.constraints.NotBlank;

import java.time.LocalDate;

@Data
public class PublishingCompanyDTO {
    @NotBlank(message = "Название издательства не может быть пустым")
    private String name;

    private LocalDate establishmentYear;

    private String contactInfo;

    private String city;
}


===== bookstorage/src/main/java/org/application/bookstorage\dto\StylesDTO.java =====

package org.application.bookstorage.dto;

import lombok.Data;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

@Data
public class StylesDTO {
    private Long id;

    @NotBlank(message = "Название стиля не может быть пустым")
    private String name;
}


===== bookstorage/src/main/java/org/application/bookstorage\repository\AuthorRepository.java =====

package org.application.bookstorage.repository;

import org.application.bookstorage.dao.Author;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AuthorRepository extends JpaRepository<Author, Integer> {
    // Метод для поиска авторов по частичному совпадению ФИО, игнорируя регистр
    List<Author> findByFioContainingIgnoreCase(String fio);
    // Метод для поиска авторов по частичному совпадению ФИО или псевдонима, игнорируя регистр
    List<Author> findByFioContainingIgnoreCaseOrNicknameContainingIgnoreCase(String fio, String nickname);

    // Дополнительные методы поиска при необходимости
}



===== bookstorage/src/main/java/org/application/bookstorage\repository\AuthorshipRepository.java =====

package org.application.bookstorage.repository;

import org.application.bookstorage.dao.Authorship;
import org.application.bookstorage.dao.AuthorshipId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface AuthorshipRepository extends JpaRepository<Authorship, AuthorshipId> {
    // Дополнительные методы поиска при необходимости
}


===== bookstorage/src/main/java/org/application/bookstorage\repository\BookRepository.java =====

package org.application.bookstorage.repository;

import org.application.bookstorage.dao.Book;
import org.springframework.data.domain.Sort;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface BookRepository extends JpaRepository<Book, String> {
    List<Book> findByNameContainingIgnoreCase(String name, Sort sort);
    // Дополнительные методы поиска при необходимости
}



===== bookstorage/src/main/java/org/application/bookstorage\repository\BookStylesRepository.java =====

package org.application.bookstorage.repository;

import org.application.bookstorage.dao.BookStyles;
import org.application.bookstorage.dao.BookStylesId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface BookStylesRepository extends JpaRepository<BookStyles, BookStylesId> {
    // Дополнительные методы поиска при необходимости
}


===== bookstorage/src/main/java/org/application/bookstorage\repository\PublishingCompanyRepository.java =====

package org.application.bookstorage.repository;

import org.application.bookstorage.dao.PublishingCompany;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface PublishingCompanyRepository extends JpaRepository<PublishingCompany, String> {

    Optional<PublishingCompany> findByName(String name);

    void deleteByName(String name);

    List<PublishingCompany> findByNameContainingIgnoreCase(String name);
    // Дополнительные методы поиска при необходимости
}



===== bookstorage/src/main/java/org/application/bookstorage\repository\StylesRepository.java =====

package org.application.bookstorage.repository;

import org.application.bookstorage.dao.Styles;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface StylesRepository extends JpaRepository<Styles, Long> {
    /**
     * Найти жанр по точному названию (игнорируя регистр).
     *
     * @param name Название жанра.
     * @return Опциональный жанр.
     */
    Optional<Styles> findByNameIgnoreCase(String name);

    /**
     * Найти жанр, название которого содержит заданную строку (игнорируя регистр).
     *
     * @param name Подстрока для поиска в названии жанра.
     * @return Список жанров.
     */
    List<Styles> findByNameContainingIgnoreCase(String name);
    // Дополнительные методы поиска при необходимости
}


===== bookstorage/src/main/java/org/application/bookstorage\service\author\AuthorService.java =====

package org.application.bookstorage.service.author;

import org.application.bookstorage.dao.Author;

import java.util.List;
import java.util.Optional;

public interface AuthorService {
    Author createAuthor(Author author);
    Optional<Author> getAuthorById(int id);
    List<Author> getAllAuthors();
    Author updateAuthor(int id, Author author);
    void deleteAuthor(int id);
    List<Author> searchAuthorsByFio(String fio);
    void deleteAuthors(List<Integer> authorIds, boolean removeEverything);

    List<Author> searchAuthors(String query); // Метод поиска по ФИО и псевдониму
}


===== bookstorage/src/main/java/org/application/bookstorage\service\author\AuthorServiceImpl.java =====

package org.application.bookstorage.service.author;

import lombok.AllArgsConstructor;
import org.application.bookstorage.dao.Author;
import org.application.bookstorage.dao.Book;
import org.application.bookstorage.repository.AuthorRepository;
import org.application.bookstorage.repository.BookRepository;
import org.springframework.stereotype.Service;

import jakarta.transaction.Transactional;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
@AllArgsConstructor
@Transactional
public class AuthorServiceImpl implements AuthorService {

    private final AuthorRepository authorRepository;
    private final BookRepository bookRepository;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(AuthorServiceImpl.class);

    @Override
    public Author createAuthor(Author author) {
        // LOGGING ADDED
        logger.info("Создание автора: {}", author);

        Author saved = authorRepository.save(author);

        // LOGGING ADDED
        logger.info("Автор сохранён с ID: {}", saved.getId());
        return saved;
    }

    @Override
    public Optional<Author> getAuthorById(int id) {
        // LOGGING ADDED
        logger.info("Получение автора по ID: {}", id);
        return authorRepository.findById(id);
    }

    @Override
    public List<Author> getAllAuthors() {
        // LOGGING ADDED
        logger.info("Получение списка всех авторов");
        List<Author> authors = authorRepository.findAll();

        // LOGGING ADDED
        logger.info("Найдено {} авторов", authors.size());
        return authors;
    }

    @Override
    public Author updateAuthor(int id, Author authorDetails) {
        // LOGGING ADDED
        logger.info("Обновление автора с ID: {}. Новые данные: {}", id, authorDetails);

        Author author = authorRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Автор не найден с id " + id));

        author.setFio(authorDetails.getFio());
        author.setBirthDate(authorDetails.getBirthDate());
        author.setCountry(authorDetails.getCountry());
        author.setNickname(authorDetails.getNickname());

        Author updated = authorRepository.save(author);

        // LOGGING ADDED
        logger.info("Автор с ID {} успешно обновлён", id);
        return updated;
    }

    @Override
    public void deleteAuthor(int id) {
        // LOGGING ADDED
        logger.info("Удаление автора с ID: {}", id);

        Author author = authorRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Автор не найден с id " + id));
        authorRepository.delete(author);

        // LOGGING ADDED
        logger.info("Автор с ID {} удалён", id);
    }

    @Override
    public List<Author> searchAuthorsByFio(String fio) {
        // LOGGING ADDED
        logger.info("Поиск авторов по ФИО (ignoring case) содержащему: {}", fio);
        return authorRepository.findByFioContainingIgnoreCase(fio);
    }

    @Override
    public List<Author> searchAuthors(String query) {
        // LOGGING ADDED
        logger.info("Поиск авторов по ФИО или псевдониму содержащим: {}", query);
        return authorRepository.findByFioContainingIgnoreCaseOrNicknameContainingIgnoreCase(query, query);
    }

    @Override
    public void deleteAuthors(List<Integer> authorIds, boolean removeEverything) {
        // LOGGING ADDED
        logger.info("Удаление авторов по списку ID: {}. Параметр removeEverything={}", authorIds, removeEverything);

        if (!removeEverything) {
            // LOGGING ADDED
            logger.info("removeEverything=false -> удаление не выполняется");
            return;
        }

        List<Author> authors = authorRepository.findAllById(authorIds);
        if (authors.size() != authorIds.size()) {
            // LOGGING ADDED
            logger.warn("Некоторые авторы из списка {} не найдены", authorIds);
            throw new RuntimeException("Некоторые авторы не найдены для удаления.");
        }

        // Сначала собираем книги, принадлежащие этим авторам
        Set<Book> booksToCheck = new HashSet<>();
        for (Author author : authors) {
            if (author.getAuthorships() != null) {
                author.getAuthorships().forEach(a -> booksToCheck.add(a.getBook()));
            }
        }

        // Удаляем книги, у которых после удаления авторов больше не останется авторов
        for (Book book : booksToCheck) {
            int totalAuthors = book.getAuthorships().size();
            long authorsToRemoveInThisBook = book.getAuthorships().stream()
                    .filter(a -> authorIds.contains(a.getAuthor().getId()))
                    .count();
            if (totalAuthors == authorsToRemoveInThisBook) {
                // LOGGING ADDED
                logger.info("Книга ISBN={} не будет иметь авторов после удаления, удаляем книгу.", book.getIsbn());
                bookRepository.delete(book);
            }
        }

        // Удаляем авторов
        authorRepository.deleteAll(authors);

        // LOGGING ADDED
        logger.info("Авторы успешно удалены по списку ID: {}", authorIds);
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\service\authorship\AuthorshipService.java =====

package org.application.bookstorage.service.authorship;

import org.application.bookstorage.dao.Authorship;
import org.application.bookstorage.dao.AuthorshipId;

import java.util.List;
import java.util.Optional;

public interface AuthorshipService {
    Authorship createAuthorship(Authorship authorship);
    Optional<Authorship> getAuthorshipById(AuthorshipId id);
    List<Authorship> getAllAuthorships();
    Authorship updateAuthorship(AuthorshipId id, Authorship authorship);
    void deleteAuthorship(AuthorshipId id);
}



===== bookstorage/src/main/java/org/application/bookstorage\service\authorship\AuthorshipServiceImpl.java =====

package org.application.bookstorage.service.authorship;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.Authorship;
import org.application.bookstorage.dao.AuthorshipId;
import org.application.bookstorage.repository.AuthorshipRepository;
import org.springframework.stereotype.Service;

import jakarta.transaction.Transactional;
import java.util.List;
import java.util.Optional;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
@RequiredArgsConstructor
@Transactional
public class AuthorshipServiceImpl implements AuthorshipService {

    private final AuthorshipRepository authorshipRepository;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(AuthorshipServiceImpl.class);

    @Override
    public Authorship createAuthorship(Authorship authorship) {
        // LOGGING ADDED
        logger.info("Создание авторства: {}", authorship);
        return authorshipRepository.save(authorship);
    }

    @Override
    public Optional<Authorship> getAuthorshipById(AuthorshipId id) {
        // LOGGING ADDED
        logger.info("Получение авторства по ключу: {}", id);
        return authorshipRepository.findById(id);
    }

    @Override
    public List<Authorship> getAllAuthorships() {
        // LOGGING ADDED
        logger.info("Получение списка всех авторств");
        List<Authorship> result = authorshipRepository.findAll();
        logger.info("Найдено {} авторств", result.size());
        return result;
    }

    @Override
    public Authorship updateAuthorship(AuthorshipId id, Authorship authorshipDetails) {
        // LOGGING ADDED
        logger.info("Обновление авторства с ключом {}. Новые данные: {}", id, authorshipDetails);

        Authorship authorship = authorshipRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Авторство не найдено с id " + id));
        authorship.setBook(authorshipDetails.getBook());
        authorship.setAuthor(authorshipDetails.getAuthor());

        Authorship updated = authorshipRepository.save(authorship);

        // LOGGING ADDED
        logger.info("Авторство с ключом {} успешно обновлено", id);
        return updated;
    }

    @Override
    public void deleteAuthorship(AuthorshipId id) {
        // LOGGING ADDED
        logger.info("Удаление авторства с ключом {}", id);

        Authorship authorship = authorshipRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Авторство не найдено с id " + id));
        authorshipRepository.delete(authorship);

        // LOGGING ADDED
        logger.info("Авторство с ключом {} удалено", id);
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\service\book\BookService.java =====

package org.application.bookstorage.service.book;

import org.application.bookstorage.dao.Book;

import java.util.List;
import java.util.Optional;

public interface BookService {
    Book createBook(Book book);
    Optional<Book> getBookByIsbn(String isbn);
    List<Book> getAllBooks(String search, String sortColumn, String sortOrder);
    Book updateBook(String isbn, Book book);
    void deleteBook(String isbn);

    // Новый метод для массового удаления
    void deleteBooks(List<String> isbns);
}


===== bookstorage/src/main/java/org/application/bookstorage\service\book\BookServiceImpl.java =====

package org.application.bookstorage.service.book;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.Book;
import org.application.bookstorage.repository.BookRepository;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import jakarta.transaction.Transactional;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
@RequiredArgsConstructor
@Transactional
public class BookServiceImpl implements BookService {

    private final BookRepository bookRepository;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(BookServiceImpl.class);

    @Override
    public Book createBook(Book book) {
        // LOGGING ADDED
        logger.info("Создание книги: {}", book);
        Book saved = bookRepository.save(book);
        logger.info("Книга сохранена: ISBN={}", saved.getIsbn());
        return saved;
    }

    @Override
    public Optional<Book> getBookByIsbn(String isbn) {
        // LOGGING ADDED
        logger.info("Получение книги по ISBN: {}", isbn);
        return bookRepository.findById(isbn);
    }

    @Override
    public List<Book> getAllBooks(String search, String sortColumn, String sortOrder) {
        // LOGGING ADDED
        logger.info("Получение всех книг (search='{}', sortColumn='{}', sortOrder='{}')", search, sortColumn, sortOrder);

        Sort sort = Sort.unsorted();
        boolean sortByAuthor = false;

        if (sortColumn != null && !sortColumn.isEmpty()) {
            if ("author".equalsIgnoreCase(sortColumn)) {
                sortByAuthor = true;
            } else {
                Sort.Direction direction = "desc".equalsIgnoreCase(sortOrder) ? Sort.Direction.DESC : Sort.Direction.ASC;
                sort = Sort.by(direction, mapSortColumn(sortColumn));
            }
        }

        List<Book> books;
        if (search != null && !search.isEmpty()) {
            // LOGGING ADDED
            logger.info("Поиск книг по названию, содержащему '{}'", search);
            books = bookRepository.findByNameContainingIgnoreCase(search, sort);
        } else {
            books = bookRepository.findAll(sort);
        }

        if (sortByAuthor) {
            // LOGGING ADDED
            logger.info("Дополнительная сортировка по первому автору");
            Comparator<Book> comparator = Comparator.comparing(book -> {
                if (book.getAuthorships() != null && !book.getAuthorships().isEmpty()) {
                    return book.getAuthorships().iterator().next().getAuthor().getFio();
                } else {
                    return "";
                }
            }, String.CASE_INSENSITIVE_ORDER);
            if ("desc".equalsIgnoreCase(sortOrder)) {
                comparator = comparator.reversed();
            }
            books.sort(comparator);
        }

        logger.info("Найдено {} книг после сортировки/фильтрации", books.size());
        return books;
    }

    private String mapSortColumn(String sortColumn) {
        switch (sortColumn) {
            case "name":
                return "name";
            case "publication_year":
                return "publicationYear";
            case "publishing_company":
                return "publishingCompany.name";
            case "count_of_books":
                return "countOfBooks";
            case "isbn":
                return "isbn";
            default:
                return "name";
        }
    }

    @Override
    public Book updateBook(String isbn, Book bookDetails) {
        // LOGGING ADDED
        logger.info("Обновление книги ISBN={}. Новые данные: {}", isbn, bookDetails);

        Book book = bookRepository.findById(isbn)
                .orElseThrow(() -> new RuntimeException("Книга не найдена с ISBN " + isbn));

        book.setName(bookDetails.getName());
        book.setPublicationYear(bookDetails.getPublicationYear());
        book.setAgeLimit(bookDetails.getAgeLimit());
        book.setPublishingCompany(bookDetails.getPublishingCompany());
        book.setPageCount(bookDetails.getPageCount());
        book.setLanguage(bookDetails.getLanguage());
        book.setCost(bookDetails.getCost());
        book.setCountOfBooks(bookDetails.getCountOfBooks());

        Book updated = bookRepository.save(book);

        // LOGGING ADDED
        logger.info("Книга ISBN={} успешно обновлена", isbn);
        return updated;
    }

    @Override
    public void deleteBook(String isbn) {
        // LOGGING ADDED
        logger.info("Удаление книги ISBN={}", isbn);

        Book book = bookRepository.findById(isbn)
                .orElseThrow(() -> new RuntimeException("Книга не найдена с ISBN " + isbn));
        bookRepository.delete(book);

        // LOGGING ADDED
        logger.info("Книга ISBN={} удалена", isbn);
    }

    @Override
    public void deleteBooks(List<String> isbns) {
        // LOGGING ADDED
        logger.info("Массовое удаление книг: {}", isbns);

        List<Book> books = bookRepository.findAllById(isbns);
        if (books.size() != isbns.size()) {
            // LOGGING ADDED
            logger.warn("Некоторые книги из списка {} не найдены", isbns);
            throw new RuntimeException("Некоторые книги не найдены для удаления.");
        }
        bookRepository.deleteAll(books);

        // LOGGING ADDED
        logger.info("Книги успешно удалены по списку ISBN: {}", isbns);
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\service\bookstyles\BookStylesService.java =====

package org.application.bookstorage.service.bookstyles;

import org.application.bookstorage.dao.BookStyles;
import org.application.bookstorage.dao.BookStylesId;

import java.util.List;
import java.util.Optional;

public interface BookStylesService {
    BookStyles createBookStyles(BookStyles bookStyles);
    Optional<BookStyles> getBookStylesById(BookStylesId id);
    List<BookStyles> getAllBookStyles();
    BookStyles updateBookStyles(BookStylesId id, BookStyles bookStyles);
    void deleteBookStyles(BookStylesId id);
}



===== bookstorage/src/main/java/org/application/bookstorage\service\bookstyles\BookStylesServiceImpl.java =====

package org.application.bookstorage.service.bookstyles;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.BookStyles;
import org.application.bookstorage.dao.BookStylesId;
import org.application.bookstorage.repository.BookStylesRepository;
import org.springframework.stereotype.Service;

import jakarta.transaction.Transactional;
import java.util.List;
import java.util.Optional;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
@RequiredArgsConstructor
@Transactional
public class BookStylesServiceImpl implements BookStylesService {

    private final BookStylesRepository bookStylesRepository;

    // LOGGING ADDED
    private static final Logger logger = LoggerFactory.getLogger(BookStylesServiceImpl.class);

    @Override
    public BookStyles createBookStyles(BookStyles bookStyles) {
        // LOGGING ADDED
        logger.info("Создание связи BookStyles: {}", bookStyles);
        return bookStylesRepository.save(bookStyles);
    }

    @Override
    public Optional<BookStyles> getBookStylesById(BookStylesId id) {
        // LOGGING ADDED
        logger.info("Получение связи BookStyles по ключу: {}", id);
        return bookStylesRepository.findById(id);
    }

    @Override
    public List<BookStyles> getAllBookStyles() {
        // LOGGING ADDED
        logger.info("Получение списка всех BookStyles");
        List<BookStyles> list = bookStylesRepository.findAll();
        logger.info("Найдено {} записей BookStyles", list.size());
        return list;
    }

    @Override
    public BookStyles updateBookStyles(BookStylesId id, BookStyles bookStylesDetails) {
        // LOGGING ADDED
        logger.info("Обновление BookStyles с ключом {}. Новые данные: {}", id, bookStylesDetails);

        BookStyles bookStyles = bookStylesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("BookStyles не найдены с id " + id));

        bookStyles.setBook(bookStylesDetails.getBook());
        bookStyles.setStyleEntity(bookStylesDetails.getStyleEntity());

        BookStyles updated = bookStylesRepository.save(bookStyles);

        // LOGGING ADDED
        logger.info("BookStyles с ключом {} успешно обновлён", id);
        return updated;
    }

    @Override
    public void deleteBookStyles(BookStylesId id) {
        // LOGGING ADDED
        logger.info("Удаление BookStyles с ключом {}", id);

        BookStyles bookStyles = bookStylesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("BookStyles не найдены с id " + id));
        bookStylesRepository.delete(bookStyles);

        // LOGGING ADDED
        logger.info("BookStyles с ключом {} удалён", id);
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\service\csv\CsvService.java =====

package org.application.bookstorage.service.csv;

import com.opencsv.*;
import com.opencsv.exceptions.CsvValidationException;
import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.*;
import org.application.bookstorage.repository.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import jakarta.transaction.Transactional;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDate;
import java.util.*;

@Service
@RequiredArgsConstructor
public class CsvService {

    private static final Logger logger = LoggerFactory.getLogger(CsvService.class);

    private final AuthorRepository authorRepository;
    private final PublishingCompanyRepository publishingCompanyRepository;
    private final BookRepository bookRepository;
    private final AuthorshipRepository authorshipRepository;
    private final StylesRepository stylesRepository;
    private final BookStylesRepository bookStylesRepository;

    // Каталог для сохранения и чтения CSV файлов
    private final String EXPORT_DIR = "csv_exports";

    /**
     * Экспортирует все данные из базы данных в CSV файлы.
     */
    @Transactional
    public void exportData() throws IOException {
        // Создание каталога для экспорта, если он не существует
        Path exportPath = Paths.get(EXPORT_DIR);
        if (!Files.exists(exportPath)) {
            Files.createDirectories(exportPath);
            logger.info("Создана директория для экспорта: {}", exportPath.toAbsolutePath());
        }

        exportAuthors();
        exportPublishingCompanies();
        exportStyles();
        exportBooks();
        exportAuthorships();
        exportBookStyles();
        logger.info("Экспорт данных завершён.");
    }

    /**
     * Импортирует все данные из CSV файлов в базу данных.
     */
    @Transactional
    public void importData() throws IOException, CsvValidationException {
        // Порядок импорта для соблюдения зависимостей
        importPublishingCompanies();
        importAuthors();
        importStyles();
        importBooks();
        importAuthorships();
        importBookStyles();
        logger.info("Импорт данных завершён.");
    }

    // =================================================================
    //                            ЭКСПОРТ
    // =================================================================

    private void exportAuthors() throws IOException {
        String[] header = {"id", "fio", "birth_date", "country", "nickname"};
        List<Author> authors = authorRepository.findAll();

        try (FileOutputStream fos = new FileOutputStream(EXPORT_DIR + "/authors.csv");
             OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
             BufferedWriter bw = new BufferedWriter(osw)) {

            // Запись BOM
            bw.write('\uFEFF');
            bw.flush();

            try (CSVWriter writer = new CSVWriter(
                    bw,
                    CSVWriter.DEFAULT_SEPARATOR,
                    CSVWriter.NO_QUOTE_CHARACTER,
                    CSVWriter.DEFAULT_ESCAPE_CHARACTER,
                    CSVWriter.DEFAULT_LINE_END)) {

                writer.writeNext(header);
                for (Author author : authors) {
                    String[] data = {
                            author.getId() != null ? String.valueOf(author.getId()) : "",
                            author.getFio(),
                            author.getBirthDate(),
                            author.getCountry(),
                            author.getNickname()
                    };
                    writer.writeNext(data);
                }
            }
            logger.info("Экспортировано {} авторов (authors.csv).", authors.size());
        }
    }

    private void exportPublishingCompanies() throws IOException {
        String[] header = {"name", "establishment_year", "contact_info", "city"};
        List<PublishingCompany> companies = publishingCompanyRepository.findAll();

        try (FileOutputStream fos = new FileOutputStream(EXPORT_DIR + "/publishing_companies.csv");
             OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
             BufferedWriter bw = new BufferedWriter(osw)) {

            bw.write('\uFEFF');
            bw.flush();

            try (CSVWriter writer = new CSVWriter(
                    bw,
                    CSVWriter.DEFAULT_SEPARATOR,
                    CSVWriter.NO_QUOTE_CHARACTER,
                    CSVWriter.DEFAULT_ESCAPE_CHARACTER,
                    CSVWriter.DEFAULT_LINE_END)) {

                writer.writeNext(header);
                for (PublishingCompany company : companies) {
                    String estYear = (company.getEstablishmentYear() == null)
                            ? ""
                            : String.valueOf(company.getEstablishmentYear());
                    String[] data = {
                            company.getName(),
                            estYear,
                            company.getContactInfo(),
                            company.getCity()
                    };
                    writer.writeNext(data);
                }
            }
            logger.info("Экспортировано {} издательств (publishing_companies.csv).", companies.size());
        }
    }

    private void exportStyles() throws IOException {
        String[] header = {"id", "name"};
        List<Styles> styles = stylesRepository.findAll();

        try (FileOutputStream fos = new FileOutputStream(EXPORT_DIR + "/styles.csv");
             OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
             BufferedWriter bw = new BufferedWriter(osw)) {

            bw.write('\uFEFF');
            bw.flush();

            try (CSVWriter writer = new CSVWriter(
                    bw,
                    CSVWriter.DEFAULT_SEPARATOR,
                    CSVWriter.NO_QUOTE_CHARACTER,
                    CSVWriter.DEFAULT_ESCAPE_CHARACTER,
                    CSVWriter.DEFAULT_LINE_END)) {

                writer.writeNext(header);
                for (Styles style : styles) {
                    String[] data = {
                            style.getId() != null ? String.valueOf(style.getId()) : "",
                            style.getName()
                    };
                    writer.writeNext(data);
                }
            }
            logger.info("Экспортировано {} стилей (styles.csv).", styles.size());
        }
    }

    private void exportBooks() throws IOException {
        String[] header = {
                "isbn", "name", "publication_year", "age_limit",
                "publishing_company", "page_count", "language", "cost", "count_of_books"
        };
        List<Book> books = bookRepository.findAll();

        try (FileOutputStream fos = new FileOutputStream(EXPORT_DIR + "/books.csv");
             OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
             BufferedWriter bw = new BufferedWriter(osw)) {

            bw.write('\uFEFF');
            bw.flush();

            try (CSVWriter writer = new CSVWriter(
                    bw,
                    CSVWriter.DEFAULT_SEPARATOR,
                    CSVWriter.NO_QUOTE_CHARACTER,
                    CSVWriter.DEFAULT_ESCAPE_CHARACTER,
                    CSVWriter.DEFAULT_LINE_END)) {

                writer.writeNext(header);
                for (Book book : books) {
                    String pubYear = (book.getPublicationYear() == null)
                            ? ""
                            : String.valueOf(book.getPublicationYear());
                    String pubCompany = (book.getPublishingCompany() != null)
                            ? book.getPublishingCompany().getName()
                            : "";
                    String[] data = {
                            book.getIsbn(),
                            book.getName(),
                            pubYear,
                            String.valueOf(book.getAgeLimit()),
                            pubCompany,
                            String.valueOf(book.getPageCount()),
                            book.getLanguage(),
                            String.valueOf(book.getCost()),
                            String.valueOf(book.getCountOfBooks())
                    };
                    writer.writeNext(data);
                }
            }
            logger.info("Экспортировано {} книг (books.csv).", books.size());
        }
    }

    private void exportAuthorships() throws IOException {
        String[] header = {"book_isbn", "author_id"};
        List<Authorship> authorships = authorshipRepository.findAll();

        try (FileOutputStream fos = new FileOutputStream(EXPORT_DIR + "/authorships.csv");
             OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
             BufferedWriter bw = new BufferedWriter(osw)) {

            bw.write('\uFEFF');
            bw.flush();

            try (CSVWriter writer = new CSVWriter(
                    bw,
                    CSVWriter.DEFAULT_SEPARATOR,
                    CSVWriter.NO_QUOTE_CHARACTER,
                    CSVWriter.DEFAULT_ESCAPE_CHARACTER,
                    CSVWriter.DEFAULT_LINE_END)) {

                writer.writeNext(header);
                for (Authorship authorship : authorships) {
                    String[] data = {
                            authorship.getBook().getIsbn(),
                            (authorship.getAuthor().getId() != null ? String.valueOf(authorship.getAuthor().getId()) : "")
                    };
                    writer.writeNext(data);
                }
            }
            logger.info("Экспортировано {} авторств (authorships.csv).", authorships.size());
        }
    }

    private void exportBookStyles() throws IOException {
        String[] header = {"book_isbn", "style_id"};
        List<BookStyles> bookStyles = bookStylesRepository.findAll();

        try (FileOutputStream fos = new FileOutputStream(EXPORT_DIR + "/book_styles.csv");
             OutputStreamWriter osw = new OutputStreamWriter(fos, StandardCharsets.UTF_8);
             BufferedWriter bw = new BufferedWriter(osw)) {

            bw.write('\uFEFF');
            bw.flush();

            try (CSVWriter writer = new CSVWriter(
                    bw,
                    CSVWriter.DEFAULT_SEPARATOR,
                    CSVWriter.NO_QUOTE_CHARACTER,
                    CSVWriter.DEFAULT_ESCAPE_CHARACTER,
                    CSVWriter.DEFAULT_LINE_END)) {

                writer.writeNext(header);
                for (BookStyles bs : bookStyles) {
                    String[] data = {
                            bs.getBook().getIsbn(),
                            (bs.getStyleEntity().getId() != null ? String.valueOf(bs.getStyleEntity().getId()) : "")
                    };
                    writer.writeNext(data);
                }
            }
            logger.info("Экспортировано {} связей книг со стилями (book_styles.csv).", bookStyles.size());
        }
    }

    // =================================================================
    //                            ИМПОРТ
    // =================================================================

    /**
     * Метод для попытки пропуска BOM, если он есть.
     * @param in входной поток
     */
    private void skipBomIfPresent(BufferedInputStream in) throws IOException {
        in.mark(3);  // Запоминаем первые 3 байта
        int b1 = in.read();
        int b2 = in.read();
        int b3 = in.read();
        // UTF-8 BOM: 0xEF,0xBB,0xBF
        if (!(b1 == 0xEF && b2 == 0xBB && b3 == 0xBF)) {
            // Если BOM не распознан, возвращаемся обратно
            in.reset();
        }
    }

    /**
     * Создаёт CSVReader, который принудительно игнорирует кавычки и парсит поля по запятой.
     */
    private CSVReader buildCsvReader(InputStreamReader isr) {
        // Настраиваем парсер, чтобы не ожидать кавычки:
        CSVParser parser = new CSVParserBuilder()
                .withSeparator(',')
                .withIgnoreQuotations(true) // игнорируем кавычки, иначе вылетит Unterminated
                .build();

        return new CSVReaderBuilder(isr)
                .withCSVParser(parser)
                .build();
    }

    private void importAuthors() throws IOException, CsvValidationException {
        Path filePath = Paths.get(EXPORT_DIR + "/authors.csv");
        if (!Files.exists(filePath)) {
            logger.warn("authors.csv не найден, пропуск импорта авторов.");
            return;
        }

        try (FileInputStream fis = new FileInputStream(filePath.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             InputStreamReader isr = new InputStreamReader(bis, StandardCharsets.UTF_8)) {

            skipBomIfPresent(bis);

            try (CSVReader reader = buildCsvReader(isr)) {
                // Пропускаем заголовок
                reader.readNext();

                int imported = 0;
                String[] nextLine;
                while ((nextLine = reader.readNext()) != null) {
                    if (nextLine.length < 5) {
                        logger.warn("Некорректная строка в authors.csv: {}", Arrays.toString(nextLine));
                        continue;
                    }
                    try {
                        String idStr = nextLine[0];
                        Integer id = null;
                        if (idStr != null && !idStr.trim().isEmpty()) {
                            id = Integer.valueOf(idStr);
                        }
                        String fio = nextLine[1];
                        String birthDate = nextLine[2];
                        String country = nextLine[3];
                        String nickname = nextLine[4];

                        if (id != null) {
                            Optional<Author> existingAuthor = authorRepository.findById(id);
                            if (existingAuthor.isPresent()) {
                                Author author = existingAuthor.get();
                                author.setFio(fio);
                                author.setBirthDate(birthDate);
                                author.setCountry(country);
                                author.setNickname(nickname);
                                authorRepository.save(author);
                                imported++;
                                continue;
                            }
                        }
                        // Создание нового
                        Author author = new Author();
                        author.setFio(fio);
                        author.setBirthDate(birthDate);
                        author.setCountry(country);
                        author.setNickname(nickname);
                        authorRepository.save(author);
                        imported++;
                    } catch (NumberFormatException e) {
                        logger.error("Ошибка парсинга числа в authors.csv: {}", Arrays.toString(nextLine), e);
                    } catch (Exception e) {
                        logger.error("Не удалось импортировать автора из строки: {}", Arrays.toString(nextLine), e);
                    }
                }
                logger.info("Импортировано {} авторов.", imported);
            }
        }
    }

    private void importPublishingCompanies() throws IOException, CsvValidationException {
        Path filePath = Paths.get(EXPORT_DIR + "/publishing_companies.csv");
        if (!Files.exists(filePath)) {
            logger.warn("publishing_companies.csv не найден, пропуск импорта издательств.");
            return;
        }

        try (FileInputStream fis = new FileInputStream(filePath.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             InputStreamReader isr = new InputStreamReader(bis, StandardCharsets.UTF_8)) {

            skipBomIfPresent(bis);

            try (CSVReader reader = buildCsvReader(isr)) {
                // Пропускаем заголовок
                reader.readNext();

                int imported = 0;
                String[] nextLine;
                while ((nextLine = reader.readNext()) != null) {
                    if (nextLine.length < 4) {
                        logger.warn("Некорректная строка в publishing_companies.csv: {}", Arrays.toString(nextLine));
                        continue;
                    }
                    try {
                        String name = nextLine[0];
                        String estYearStr = nextLine[1];
                        String contactInfo = nextLine[2];
                        String city = nextLine[3];

                        LocalDate establishmentYear = null;
                        if (estYearStr != null && !estYearStr.trim().isEmpty()) {
                            if (estYearStr.length() == 4) {
                                estYearStr += "-01-01";
                            }
                            establishmentYear = LocalDate.parse(estYearStr);
                        }

                        Optional<PublishingCompany> existingCompany = publishingCompanyRepository.findById(name);
                        if (existingCompany.isPresent()) {
                            // Обновление
                            PublishingCompany company = existingCompany.get();
                            company.setEstablishmentYear(establishmentYear);
                            company.setContactInfo(contactInfo);
                            company.setCity(city);
                            publishingCompanyRepository.save(company);
                        } else {
                            // Создание нового
                            PublishingCompany company = new PublishingCompany();
                            company.setName(name);
                            company.setEstablishmentYear(establishmentYear);
                            company.setContactInfo(contactInfo);
                            company.setCity(city);
                            publishingCompanyRepository.save(company);
                        }
                        imported++;
                    } catch (NumberFormatException e) {
                        logger.error("Ошибка парсинга года в publishing_companies.csv: {}", Arrays.toString(nextLine), e);
                    } catch (Exception e) {
                        logger.error("Не удалось импортировать издательство из строки: {}", Arrays.toString(nextLine), e);
                    }
                }
                logger.info("Импортировано {} издательств.", imported);
            }
        }
    }

    private void importStyles() throws IOException, CsvValidationException {
        Path filePath = Paths.get(EXPORT_DIR + "/styles.csv");
        if (!Files.exists(filePath)) {
            logger.warn("styles.csv не найден, пропуск импорта стилей.");
            return;
        }

        try (FileInputStream fis = new FileInputStream(filePath.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             InputStreamReader isr = new InputStreamReader(bis, StandardCharsets.UTF_8)) {

            skipBomIfPresent(bis);

            // Подключаем наш парсер, игнорирующий кавычки
            try (CSVReader reader = buildCsvReader(isr)) {
                // пропуск заголовка
                reader.readNext();

                int imported = 0;
                String[] nextLine;
                while ((nextLine = reader.readNext()) != null) {
                    if (nextLine.length < 2) {
                        logger.warn("Некорректная строка в styles.csv: {}", Arrays.toString(nextLine));
                        continue;
                    }
                    try {
                        String idStr = nextLine[0];
                        Long id = null;
                        if (idStr != null && !idStr.trim().isEmpty()) {
                            id = Long.valueOf(idStr);
                        }
                        String name = nextLine[1];

                        if (id != null) {
                            Optional<Styles> existingStyle = stylesRepository.findById(id);
                            if (existingStyle.isPresent()) {
                                Styles style = existingStyle.get();
                                style.setName(name);
                                stylesRepository.save(style);
                                imported++;
                                continue;
                            }
                        }
                        // Создание нового
                        Styles style = new Styles();
                        style.setName(name);
                        stylesRepository.save(style);
                        imported++;
                    } catch (NumberFormatException e) {
                        logger.error("Ошибка парсинга числа в styles.csv: {}", Arrays.toString(nextLine), e);
                    } catch (Exception e) {
                        logger.error("Не удалось импортировать стиль из строки: {}", Arrays.toString(nextLine), e);
                    }
                }
                logger.info("Импортировано {} стилей.", imported);
            }
        }
    }

    private void importBooks() throws IOException, CsvValidationException {
        Path filePath = Paths.get(EXPORT_DIR + "/books.csv");
        if (!Files.exists(filePath)) {
            logger.warn("books.csv не найден, пропуск импорта книг.");
            return;
        }

        try (FileInputStream fis = new FileInputStream(filePath.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             InputStreamReader isr = new InputStreamReader(bis, StandardCharsets.UTF_8)) {

            skipBomIfPresent(bis);

            try (CSVReader reader = buildCsvReader(isr)) {
                // пропуск заголовка
                reader.readNext();

                int imported = 0;
                String[] nextLine;
                while ((nextLine = reader.readNext()) != null) {
                    if (nextLine.length < 9) {
                        logger.warn("Некорректная строка в books.csv: {}", Arrays.toString(nextLine));
                        continue;
                    }
                    try {
                        String isbn = nextLine[0];
                        String name = nextLine[1];
                        String pubYearStr = nextLine[2];
                        float ageLimit = Float.parseFloat(nextLine[3]);
                        String publishingCompanyName = nextLine[4];
                        int pageCount = Integer.parseInt(nextLine[5]);
                        String language = nextLine[6];
                        float cost = Float.parseFloat(nextLine[7]);
                        int countOfBooks = Integer.parseInt(nextLine[8]);

                        LocalDate publicationYear = null;
                        if (pubYearStr != null && !pubYearStr.trim().isEmpty()) {
                            publicationYear = LocalDate.parse(pubYearStr);
                        }

                        PublishingCompany publishingCompany = null;
                        if (publishingCompanyName != null && !publishingCompanyName.isEmpty()) {
                            publishingCompany = publishingCompanyRepository.findById(publishingCompanyName)
                                    .orElseThrow(() -> new RuntimeException("Издательство не найдено: " + publishingCompanyName));
                        }

                        Optional<Book> existingBook = bookRepository.findById(isbn);
                        if (existingBook.isPresent()) {
                            // Обновление
                            Book book = existingBook.get();
                            book.setName(name);
                            book.setPublicationYear(publicationYear);
                            book.setAgeLimit(ageLimit);
                            book.setPublishingCompany(publishingCompany);
                            book.setPageCount(pageCount);
                            book.setLanguage(language);
                            book.setCost(new java.math.BigDecimal(cost));
                            book.setCountOfBooks(countOfBooks);
                            bookRepository.save(book);
                        } else {
                            // Создание нового
                            Book book = new Book();
                            book.setIsbn(isbn);
                            book.setName(name);
                            book.setPublicationYear(publicationYear);
                            book.setAgeLimit(ageLimit);
                            book.setPublishingCompany(publishingCompany);
                            book.setPageCount(pageCount);
                            book.setLanguage(language);
                            book.setCost(new java.math.BigDecimal(cost));
                            book.setCountOfBooks(countOfBooks);
                            bookRepository.save(book);
                        }
                        imported++;
                    } catch (NumberFormatException e) {
                        logger.error("Ошибка парсинга числа в books.csv: {}", Arrays.toString(nextLine), e);
                    } catch (Exception e) {
                        logger.error("Не удалось импортировать книгу из строки: {}", Arrays.toString(nextLine), e);
                    }
                }
                logger.info("Импортировано {} книг.", imported);
            }
        }
    }

    private void importAuthorships() throws IOException, CsvValidationException {
        Path filePath = Paths.get(EXPORT_DIR + "/authorships.csv");
        if (!Files.exists(filePath)) {
            logger.warn("authorships.csv не найден, пропуск импорта авторств.");
            return;
        }

        try (FileInputStream fis = new FileInputStream(filePath.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             InputStreamReader isr = new InputStreamReader(bis, StandardCharsets.UTF_8)) {

            skipBomIfPresent(bis);

            try (CSVReader reader = buildCsvReader(isr)) {
                // пропуск заголовка
                reader.readNext();

                int imported = 0;
                String[] nextLine;
                while ((nextLine = reader.readNext()) != null) {
                    if (nextLine.length < 2) {
                        logger.warn("Некорректная строка в authorships.csv: {}", Arrays.toString(nextLine));
                        continue;
                    }
                    try {
                        String bookIsbn = nextLine[0];
                        String authorIdStr = nextLine[1];
                        Integer authorId = null;
                        if (authorIdStr != null && !authorIdStr.trim().isEmpty()) {
                            authorId = Integer.valueOf(authorIdStr);
                        }

                        if (bookIsbn == null || bookIsbn.trim().isEmpty() || authorId == null) {
                            logger.warn("Некорректные данные для авторства: {}", Arrays.toString(nextLine));
                            continue;
                        }

                        Optional<Book> bookOpt = bookRepository.findById(bookIsbn);
                        Optional<Author> authorOpt = authorRepository.findById(authorId);

                        if (bookOpt.isPresent() && authorOpt.isPresent()) {
                            Book book = bookOpt.get();
                            Author author = authorOpt.get();
                            AuthorshipId id = new AuthorshipId(bookIsbn, authorId);
                            Optional<Authorship> existingAuthorship = authorshipRepository.findById(id);
                            if (!existingAuthorship.isPresent()) {
                                Authorship authorship = new Authorship();
                                authorship.setId(id);
                                authorship.setBook(book);
                                authorship.setAuthor(author);
                                authorshipRepository.save(authorship);
                                imported++;
                            } else {
                                logger.debug("Авторство уже существует: ISBN={}, AuthorID={}", bookIsbn, authorId);
                            }
                        } else {
                            logger.warn("Книга или автор не найдены для авторства: ISBN={}, AuthorID={}", bookIsbn, authorId);
                        }
                    } catch (NumberFormatException e) {
                        logger.error("Ошибка парсинга числа в authorships.csv: {}", Arrays.toString(nextLine), e);
                    } catch (Exception e) {
                        logger.error("Не удалось импортировать авторство из строки: {}", Arrays.toString(nextLine), e);
                    }
                }
                logger.info("Импортировано {} авторств.", imported);
            }
        }
    }

    private void importBookStyles() throws IOException, CsvValidationException {
        Path filePath = Paths.get(EXPORT_DIR + "/book_styles.csv");
        if (!Files.exists(filePath)) {
            logger.warn("book_styles.csv не найден, пропуск импорта стилей книг.");
            return;
        }

        try (FileInputStream fis = new FileInputStream(filePath.toFile());
             BufferedInputStream bis = new BufferedInputStream(fis);
             InputStreamReader isr = new InputStreamReader(bis, StandardCharsets.UTF_8)) {

            skipBomIfPresent(bis);

            try (CSVReader reader = buildCsvReader(isr)) {
                // Пропускаем строку заголовка
                reader.readNext();

                int imported = 0;
                String[] nextLine;
                while ((nextLine = reader.readNext()) != null) {
                    if (nextLine.length < 2) {
                        logger.warn("Некорректная строка в book_styles.csv: {}", Arrays.toString(nextLine));
                        continue;
                    }
                    try {
                        String bookIsbn = nextLine[0];
                        String styleIdStr = nextLine[1];
                        Long styleId = null;
                        if (styleIdStr != null && !styleIdStr.trim().isEmpty()) {
                            styleId = Long.valueOf(styleIdStr);
                        }

                        if (bookIsbn == null || bookIsbn.trim().isEmpty() || styleId == null) {
                            logger.warn("Некорректные данные для связи книги со стилем: {}", Arrays.toString(nextLine));
                            continue;
                        }

                        Optional<Book> bookOpt = bookRepository.findById(bookIsbn);
                        Optional<Styles> styleOpt = stylesRepository.findById(styleId);

                        if (bookOpt.isPresent() && styleOpt.isPresent()) {
                            Book book = bookOpt.get();
                            Styles style = styleOpt.get();

                            BookStylesId id = new BookStylesId(bookIsbn, styleId);
                            Optional<BookStyles> existingBookStyle = bookStylesRepository.findById(id);

                            if (!existingBookStyle.isPresent()) {
                                BookStyles bookStyles = new BookStyles();
                                bookStyles.setId(id);
                                bookStyles.setBook(book);
                                bookStyles.setStyleEntity(style);
                                bookStylesRepository.save(bookStyles);
                                imported++;
                            } else {
                                logger.debug("Связь книги со стилем уже существует: ISBN={}, StyleID={}", bookIsbn, styleId);
                            }
                        } else {
                            logger.warn("Книга или стиль не найдены для связи: ISBN={}, StyleID={}", bookIsbn, styleId);
                        }
                    } catch (NumberFormatException e) {
                        logger.error("Ошибка парсинга числа в book_styles.csv: {}", Arrays.toString(nextLine), e);
                    } catch (Exception e) {
                        logger.error("Не удалось импортировать связь книги со стилем из строки: {}", Arrays.toString(nextLine), e);
                    }
                }
                logger.info("Импортировано {} связей книг со стилями.", imported);
            }
        }
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\service\publishingcompany\PublishingCompanyService.java =====

package org.application.bookstorage.service.publishingcompany;

import org.application.bookstorage.dao.PublishingCompany;

import java.util.List;
import java.util.Optional;

public interface PublishingCompanyService {
    PublishingCompany createPublishingCompany(PublishingCompany company);
    Optional<PublishingCompany> getPublishingCompanyByName(String name);
    List<PublishingCompany> getAllPublishingCompanies();
    PublishingCompany updatePublishingCompany(String name, PublishingCompany company);
    void deletePublishingCompanies(List<String> names);
    List<PublishingCompany> searchPublishingCompaniesByName(String name);
}


===== bookstorage/src/main/java/org/application/bookstorage\service\publishingcompany\PublishingCompanyServiceImpl.java =====

package org.application.bookstorage.service.publishingcompany;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.Book;
import org.application.bookstorage.dao.PublishingCompany;
import org.application.bookstorage.repository.BookRepository;
import org.application.bookstorage.repository.PublishingCompanyRepository;
import org.springframework.stereotype.Service;

import jakarta.transaction.Transactional;
import java.util.List;
import java.util.Optional;

// LOGGING ADDED
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Service
@RequiredArgsConstructor
@Transactional
public class PublishingCompanyServiceImpl implements PublishingCompanyService {

    private final PublishingCompanyRepository publishingCompanyRepository;
    private final BookRepository bookRepository;

    // LOGGING ADDED: Инициализация логгера для этого сервиса
    private static final Logger logger = LoggerFactory.getLogger(PublishingCompanyServiceImpl.class);

    @Override
    public PublishingCompany createPublishingCompany(PublishingCompany company) {
        logger.info("Создание издательства: {}", company);
        PublishingCompany savedCompany = publishingCompanyRepository.save(company);
        logger.info("Издательство успешно создано: {}", savedCompany.getName());
        return savedCompany;
    }

    @Override
    public Optional<PublishingCompany> getPublishingCompanyByName(String name) {
        logger.info("Получение издательства по имени: {}", name);
        Optional<PublishingCompany> companyOpt = publishingCompanyRepository.findById(name);
        if (companyOpt.isPresent()) {
            logger.info("Издательство найдено: {}", name);
        } else {
            logger.warn("Издательство с именем {} не найдено", name);
        }
        return companyOpt;
    }

    @Override
    public List<PublishingCompany> getAllPublishingCompanies() {
        logger.info("Получение всех издательств");
        List<PublishingCompany> companies = publishingCompanyRepository.findAll();
        logger.info("Найдено {} издательств", companies.size());
        return companies;
    }

    @Override
    public PublishingCompany updatePublishingCompany(String originalName, PublishingCompany updatedCompany) {
        logger.info("Обновление издательства. Оригинальное имя: {}, новые данные: {}", originalName, updatedCompany);
        // Находим исходное издательство по старому названию
        PublishingCompany oldCompany = publishingCompanyRepository.findById(originalName)
                .orElseThrow(() -> {
                    logger.error("Издательство не найдено с именем {}", originalName);
                    return new RuntimeException("Издательство не найдено с именем " + originalName);
                });

        String newName = updatedCompany.getName();

        if (!originalName.equals(newName)) {
            // Проверяем, что новое имя не занято
            if (publishingCompanyRepository.existsById(newName)) {
                logger.error("Издательство с названием {} уже существует", newName);
                throw new RuntimeException("Издательство с названием " + newName + " уже существует.");
            }

            // Создаём новое издательство
            PublishingCompany newCompany = new PublishingCompany();
            newCompany.setName(newName);
            newCompany.setEstablishmentYear(updatedCompany.getEstablishmentYear());
            newCompany.setContactInfo(updatedCompany.getContactInfo());
            newCompany.setCity(updatedCompany.getCity());
            newCompany.setBooks(oldCompany.getBooks());

            // Обновляем связь в книгах
            for (Book book : oldCompany.getBooks()) {
                book.setPublishingCompany(newCompany);
                logger.debug("Обновлена связь книги (ISBN={}) на новое издательство {}", book.getIsbn(), newName);
            }

            // Сохраняем новое издательство
            publishingCompanyRepository.save(newCompany);
            logger.info("Новое издательство {} сохранено", newName);

            // Удаляем старое издательство
            publishingCompanyRepository.delete(oldCompany);
            logger.info("Старое издательство {} удалено", originalName);

            return newCompany;
        } else {
            // Если название не меняется, просто обновляем остальные поля
            oldCompany.setEstablishmentYear(updatedCompany.getEstablishmentYear());
            oldCompany.setContactInfo(updatedCompany.getContactInfo());
            oldCompany.setCity(updatedCompany.getCity());
            PublishingCompany savedOld = publishingCompanyRepository.save(oldCompany);
            logger.info("Издательство {} обновлено (без смены имени)", originalName);
            return savedOld;
        }
    }

    @Override
    public void deletePublishingCompanies(List<String> names) {
        logger.info("Массовое удаление издательств. Список имён: {}", names);
        List<PublishingCompany> companies = publishingCompanyRepository.findAllById(names);
        if (companies.size() != names.size()) {
            logger.error("Некоторые издательства не найдены для удаления. Ожидается {} , найдено {}", names.size(), companies.size());
            throw new RuntimeException("Некоторые издательства не найдены для удаления.");
        }
        publishingCompanyRepository.deleteAll(companies);
        logger.info("Издательства успешно удалены: {}", names);
    }

    @Override
    public List<PublishingCompany> searchPublishingCompaniesByName(String name) {
        logger.info("Поиск издательств, содержащих: {}", name);
        List<PublishingCompany> result = publishingCompanyRepository.findByNameContainingIgnoreCase(name);
        logger.info("Найдено {} издательств по запросу '{}'", result.size(), name);
        return result;
    }
}


===== bookstorage/src/main/java/org/application/bookstorage\service\styles\StylesService.java =====

package org.application.bookstorage.service.styles;

import org.application.bookstorage.dao.Styles;

import java.util.List;
import java.util.Optional;

public interface StylesService {
    Styles createStyle(Styles style);
    Optional<Styles> getStyleById(Long id);
    List<Styles> getAllStyles();
    Styles updateStyle(Long id, Styles style);
    void deleteStyle(Long id);

    Optional<Styles> getStyleByName(String name);
    List<Styles> searchStylesByName(String name);
}



===== bookstorage/src/main/java/org/application/bookstorage\service\styles\StylesServiceImpl.java =====

package org.application.bookstorage.service.styles;

import lombok.RequiredArgsConstructor;
import org.application.bookstorage.dao.Styles;
import org.application.bookstorage.repository.StylesRepository;
import org.springframework.stereotype.Service;

import jakarta.transaction.Transactional;
import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
@Transactional
public class StylesServiceImpl implements StylesService {

    private final StylesRepository stylesRepository;

    @Override
    public Styles createStyle(Styles style) {
        return stylesRepository.save(style);
    }

    @Override
    public Optional<Styles> getStyleById(Long id) {
        return stylesRepository.findById(id);
    }

    @Override
    public List<Styles> getAllStyles() {
        return stylesRepository.findAll();
    }

    @Override
    public Styles updateStyle(Long id, Styles styleDetails) {
        Styles style = stylesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Стиль не найден с id " + id));
        style.setName(styleDetails.getName());
        // Обновление других полей при необходимости
        return stylesRepository.save(style);
    }

    @Override
    public void deleteStyle(Long id) {
        Styles style = stylesRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Стиль не найден с id " + id));
        stylesRepository.delete(style);
    }

    @Override
    public Optional<Styles> getStyleByName(String name) {
        // Попытка найти жанр с точным совпадением
        Optional<Styles> exactMatch = stylesRepository.findByNameIgnoreCase(name);
        if (exactMatch.isPresent()) {
            return exactMatch;
        }
        // Если точного совпадения нет, ищем жанр, название которого содержит заданную строку
        List<Styles> partialMatches = stylesRepository.findByNameContainingIgnoreCase(name);
        if (!partialMatches.isEmpty()) {
            // Возвращаем первый найденный жанр из частичных совпадений
            return Optional.of(partialMatches.get(0));
        }
        // Если совпадений нет, возвращаем пустой Optional
        return Optional.empty();
    }

    @Override
    public List<Styles> searchStylesByName(String name) {
        return stylesRepository.findByNameContainingIgnoreCase(name);
    }
}


===== bookstorage/src/test/java/org/application/bookstorage\controller\author\AuthorControllerTest.java =====

package org.application.bookstorage.controller.author;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.application.bookstorage.dao.Author;
import org.application.bookstorage.dto.AuthorDTO;
import org.application.bookstorage.service.author.AuthorService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.beans.factory.annotation.Autowired;

import java.util.*;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ExtendWith(SpringExtension.class)
@WebMvcTest(AuthorController.class)
class AuthorControllerTest {

    private static final Logger logger = LoggerFactory.getLogger(AuthorControllerTest.class);

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private AuthorService authorService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void createAuthor_ShouldReturnCreated() throws Exception {
        logger.info("Тест контроллера: createAuthor_ShouldReturnCreated");

        AuthorDTO requestDto = new AuthorDTO();
        requestDto.setFio("Новый Автор");
        requestDto.setBirthDate("2000-01-01");
        requestDto.setCountry("Россия");
        requestDto.setNickname("newnick");

        Author created = new Author();
        created.setId(1);
        created.setFio("Новый Автор");

        when(authorService.createAuthor(any(Author.class))).thenReturn(created);

        mockMvc.perform(post("/api/authors")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(requestDto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.fio").value("Новый Автор"));
    }

    @Test
    void getAuthorById_ShouldReturnOkIfFound() throws Exception {
        logger.info("Тест контроллера: getAuthorById_ShouldReturnOkIfFound");

        Author author = new Author();
        author.setId(1);
        author.setFio("Автор 1");

        when(authorService.getAuthorById(1)).thenReturn(Optional.of(author));

        mockMvc.perform(get("/api/authors/{id}", 1))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.fio").value("Автор 1"));
    }

    @Test
    void getAuthorById_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: getAuthorById_ShouldReturnNotFoundIfMissing");

        when(authorService.getAuthorById(999)).thenReturn(Optional.empty());

        mockMvc.perform(get("/api/authors/{id}", 999))
                .andExpect(status().isNotFound());
    }

    @Test
    void getAllAuthors_ShouldReturnOkAndList() throws Exception {
        logger.info("Тест контроллера: getAllAuthors_ShouldReturnOkAndList");

        Author author1 = new Author();
        author1.setId(1);
        author1.setFio("Автор 1");
        Author author2 = new Author();
        author2.setId(2);
        author2.setFio("Автор 2");

        when(authorService.getAllAuthors()).thenReturn(Arrays.asList(author1, author2));

        mockMvc.perform(get("/api/authors"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].fio").value("Автор 1"))
                .andExpect(jsonPath("$[1].fio").value("Автор 2"));
    }

    @Test
    void updateAuthor_ShouldReturnOkIfUpdated() throws Exception {
        logger.info("Тест контроллера: updateAuthor_ShouldReturnOkIfUpdated");

        AuthorDTO requestDto = new AuthorDTO();
        requestDto.setFio("Обновлённый Автор");
        requestDto.setCountry("Россия");

        Author updated = new Author();
        updated.setId(1);
        updated.setFio("Обновлённый Автор");

        when(authorService.updateAuthor(eq(1), any(Author.class))).thenReturn(updated);

        mockMvc.perform(put("/api/authors/{id}", 1)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(requestDto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.fio").value("Обновлённый Автор"));
    }

    @Test
    void updateAuthor_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: updateAuthor_ShouldReturnNotFoundIfMissing");

        when(authorService.updateAuthor(eq(999), any(Author.class))).thenThrow(new RuntimeException("Not found"));

        AuthorDTO requestDto = new AuthorDTO();
        requestDto.setFio("Кто-то");

        mockMvc.perform(put("/api/authors/{id}", 999)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(requestDto)))
                .andExpect(status().isNotFound());
    }

    @Test
    void deleteAuthor_ShouldReturnNoContentIfDeleted() throws Exception {
        logger.info("Тест контроллера: deleteAuthor_ShouldReturnNoContentIfDeleted");

        mockMvc.perform(delete("/api/authors/{id}", 1))
                .andExpect(status().isNoContent());
        verify(authorService, times(1)).deleteAuthor(1);
    }

    @Test
    void deleteAuthor_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: deleteAuthor_ShouldReturnNotFoundIfMissing");

        doThrow(new RuntimeException("Not found")).when(authorService).deleteAuthor(999);

        mockMvc.perform(delete("/api/authors/{id}", 999))
                .andExpect(status().isNotFound());
    }

    @Test
    void deleteAuthorsBulk_ShouldReturnNoContent() throws Exception {
        logger.info("Тест контроллера: deleteAuthorsBulk_ShouldReturnNoContent");

        List<Integer> ids = Arrays.asList(1, 2, 3);

        mockMvc.perform(delete("/api/authors/bulk-delete?removeEverything=true")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(ids)))
                .andExpect(status().isNoContent());

        verify(authorService, times(1)).deleteAuthors(eq(ids), eq(true));
    }

    @Test
    void searchAuthors_ShouldReturnList() throws Exception {
        logger.info("Тест контроллера: searchAuthors_ShouldReturnList");

        Author author = new Author();
        author.setId(1);
        author.setFio("Иванов");

        when(authorService.searchAuthors("Иван")).thenReturn(Collections.singletonList(author));

        mockMvc.perform(get("/api/authors/search").param("q", "Иван"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].fio").value("Иванов"));
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\controller\authorship\AuthorshipControllerTest.java =====

package org.application.bookstorage.controller.authorship;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.application.bookstorage.dao.Authorship;
import org.application.bookstorage.dao.AuthorshipId;
import org.application.bookstorage.dao.Author;
import org.application.bookstorage.dao.Book;
import org.application.bookstorage.dto.AuthorshipDTO;
import org.application.bookstorage.service.authorship.AuthorshipService;
import org.application.bookstorage.service.author.AuthorService;
import org.application.bookstorage.service.book.BookService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import static org.mockito.ArgumentMatchers.any;


import java.util.*;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ExtendWith(SpringExtension.class)
@WebMvcTest(AuthorshipController.class)
class AuthorshipControllerTest {

    private static final Logger logger = LoggerFactory.getLogger(AuthorshipControllerTest.class);

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private AuthorshipService authorshipService;

    @MockitoBean
    private BookService bookService;

    @MockitoBean
    private AuthorService authorService;

    @Test
    void createAuthorship_ShouldReturnCreated() throws Exception {
        logger.info("Тест контроллера: createAuthorship_ShouldReturnCreated");
        ObjectMapper objectMapper = new ObjectMapper();

        AuthorshipDTO dto = new AuthorshipDTO();
        dto.setBookIsbn("ISBN-123");
        dto.setAuthorId(1);

        Book book = new Book();
        book.setIsbn("ISBN-123");

        Author author = new Author();
        author.setId(1);

        when(bookService.getBookByIsbn("ISBN-123")).thenReturn(Optional.of(book));
        when(authorService.getAuthorById(1)).thenReturn(Optional.of(author));
        when(authorshipService.createAuthorship(any(Authorship.class)))
                .thenReturn(new Authorship(new AuthorshipId("ISBN-123", 1), book, author));

        mockMvc.perform(post("/api/authorships")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isCreated());
    }

    @Test
    void getAuthorshipById_ShouldReturnOkIfFound() throws Exception {
        logger.info("Тест контроллера: getAuthorshipById_ShouldReturnOkIfFound");
        Authorship authorship = new Authorship(
                new AuthorshipId("ISBN-123", 1),
                new Book(),
                new Author()
        );

        when(authorshipService.getAuthorshipById(new AuthorshipId("ISBN-123", 1)))
                .thenReturn(Optional.of(authorship));

        mockMvc.perform(get("/api/authorships/ISBN-123/1"))
                .andExpect(status().isOk());
    }

    @Test
    void getAuthorshipById_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: getAuthorshipById_ShouldReturnNotFoundIfMissing");
        when(authorshipService.getAuthorshipById(new AuthorshipId("ISBN-999", 999)))
                .thenReturn(Optional.empty());

        mockMvc.perform(get("/api/authorships/ISBN-999/999"))
                .andExpect(status().isNotFound());
    }

    @Test
    void getAllAuthorships_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: getAllAuthorships_ShouldReturnOk");
        when(authorshipService.getAllAuthorships()).thenReturn(Collections.emptyList());

        mockMvc.perform(get("/api/authorships"))
                .andExpect(status().isOk());
    }

    @Test
    void updateAuthorship_ShouldReturnOkIfUpdated() throws Exception {
        logger.info("Тест контроллера: updateAuthorship_ShouldReturnOkIfUpdated");
        ObjectMapper objectMapper = new ObjectMapper();

        AuthorshipDTO dto = new AuthorshipDTO();
        dto.setBookIsbn("ISBN-456");
        dto.setAuthorId(2);

        // Мокаем получение новой книги и нового автора
        Book newBook = new Book();
        newBook.setIsbn("ISBN-456");
        Author newAuthor = new Author();
        newAuthor.setId(2);

        when(bookService.getBookByIsbn("ISBN-456")).thenReturn(Optional.of(newBook));
        when(authorService.getAuthorById(2)).thenReturn(Optional.of(newAuthor));

        // Старый ID, полученный из URL: (ISBN-123, 1)
        AuthorshipId oldId = new AuthorshipId("ISBN-123", 1);

        // Формируем корректный объект Authorship (без null для book и author)
        Book existingBook = new Book();
        existingBook.setIsbn("ISBN-123");
        Author existingAuthor = new Author();
        existingAuthor.setId(1);
        Authorship old = new Authorship(oldId, existingBook, existingAuthor);

        // Мокаем вызов updateAuthorship, чтобы вернуть 'old'
        when(authorshipService.updateAuthorship(any(AuthorshipId.class), any(Authorship.class))).thenReturn(old);

        mockMvc.perform(put("/api/authorships/ISBN-123/1")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isOk());
    }



    @Test
    void updateAuthorship_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: updateAuthorship_ShouldReturnNotFoundIfMissing");
        ObjectMapper objectMapper = new ObjectMapper();

        AuthorshipDTO dto = new AuthorshipDTO();
        dto.setBookIsbn("NoBook");
        dto.setAuthorId(999);

        when(bookService.getBookByIsbn("NoBook")).thenReturn(Optional.empty());

        mockMvc.perform(put("/api/authorships/ISBN-123/1")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isNotFound());
    }

    @Test
    void deleteAuthorship_ShouldReturnNoContent() throws Exception {
        logger.info("Тест контроллера: deleteAuthorship_ShouldReturnNoContent");

        mockMvc.perform(delete("/api/authorships/{bookIsbn}/{authorId}", "ISBN-123", 1))
                .andExpect(status().isNoContent());
        verify(authorshipService, times(1))
                .deleteAuthorship(new AuthorshipId("ISBN-123", 1));
    }

    @Test
    void deleteAuthorship_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: deleteAuthorship_ShouldReturnNotFoundIfMissing");

        doThrow(new RuntimeException("Not found")).when(authorshipService)
                .deleteAuthorship(new AuthorshipId("NOBOOK", 999));

        mockMvc.perform(delete("/api/authorships/NOBOOK/999"))
                .andExpect(status().isNotFound());
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\controller\book\BookControllerTest.java =====

package org.application.bookstorage.controller.book;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.application.bookstorage.config.JacksonTestConfig;
import org.application.bookstorage.dao.Book;
import org.application.bookstorage.dto.BookDTO;
import org.application.bookstorage.service.author.AuthorService;
import org.application.bookstorage.service.authorship.AuthorshipService;
import org.application.bookstorage.service.book.BookService;
import org.application.bookstorage.service.bookstyles.BookStylesService;
import org.application.bookstorage.service.publishingcompany.PublishingCompanyService;
import org.application.bookstorage.service.styles.StylesService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;

import org.springframework.context.annotation.Import;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.*;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;

import static org.mockito.Mockito.*;

@ExtendWith(SpringExtension.class)
@WebMvcTest(BookController.class)
@Import(JacksonTestConfig.class)
class BookControllerTest {

    private static final Logger logger = LoggerFactory.getLogger(BookControllerTest.class);

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private BookService bookService;
    @MockitoBean
    private PublishingCompanyService publishingCompanyService;
    @MockitoBean
    private AuthorService authorService;
    @MockitoBean
    private AuthorshipService authorshipService;
    @MockitoBean
    private StylesService stylesService;
    @MockitoBean
    private BookStylesService bookStylesService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void deleteBooksBulk_ShouldReturnNoContent() throws Exception {
        logger.info("Тест контроллера: deleteBooksBulk_ShouldReturnNoContent");

        List<String> isbns = Arrays.asList("ISBN-123", "ISBN-456");

        mockMvc.perform(delete("/api/books/bulk-delete")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(isbns)))
                .andExpect(status().isNoContent());

        verify(bookService, times(1)).deleteBooks(isbns);
    }

    @Test
    void createBook_ShouldReturnCreated() throws Exception {
        logger.info("Тест контроллера: createBook_ShouldReturnCreated");

        BookDTO dto = new BookDTO();
        dto.setIsbn("ISBN-123");
        dto.setName("Тестовая книга");
        dto.setPublicationYear(LocalDate.of(2020, 1, 1));
        dto.setAgeLimit(18f);
        dto.setPublishingCompany("TestPub");
        dto.setPageCount(100);
        dto.setLanguage("Russian");
        dto.setCost(BigDecimal.valueOf(500));
        dto.setCountOfBooks(10);
        dto.setAuthors(new ArrayList<>());
        dto.setGenres(new ArrayList<>());

        Book created = new Book();
        created.setIsbn("ISBN-123");
        created.setName("Тестовая книга");

        when(bookService.createBook(any(Book.class))).thenReturn(created);

        mockMvc.perform(post("/api/books")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.isbn").value("ISBN-123"));
    }

    @Test
    void createBook_ShouldReturnBadRequestIfError() throws Exception {
        logger.info("Тест контроллера: createBook_ShouldReturnBadRequestIfError");
        BookDTO dto = new BookDTO();
        // Заполним частично или оставим пустые поля, чтобы имитировать ошибку
        // Но реальная ошибка может быть брошена сервисом

        when(bookService.createBook(any(Book.class))).thenThrow(new RuntimeException("Some error"));

        mockMvc.perform(post("/api/books")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest());
    }

    @Test
    void getBookByIsbn_ShouldReturnOkIfFound() throws Exception {
        logger.info("Тест контроллера: getBookByIsbn_ShouldReturnOkIfFound");

        Book book = new Book();
        book.setIsbn("ISBN-123");
        book.setName("Книга 1");

        when(bookService.getBookByIsbn("ISBN-123")).thenReturn(Optional.of(book));

        mockMvc.perform(get("/api/books/{isbn}", "ISBN-123"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("Книга 1"));
    }

    @Test
    void getBookByIsbn_ShouldReturnNotFound() throws Exception {
        logger.info("Тест контроллера: getBookByIsbn_ShouldReturnNotFound");

        when(bookService.getBookByIsbn("NOT-EXIST")).thenReturn(Optional.empty());

        mockMvc.perform(get("/api/books/{isbn}", "NOT-EXIST"))
                .andExpect(status().isNotFound());
    }

    @Test
    void getAllBooks_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: getAllBooks_ShouldReturnOk");

        when(bookService.getAllBooks(null, null, null)).thenReturn(Collections.emptyList());

        mockMvc.perform(get("/api/books"))
                .andExpect(status().isOk());
    }

    @Test
    void updateBook_ShouldReturnOkIfUpdated() throws Exception {
        logger.info("Тест контроллера: updateBook_ShouldReturnOkIfUpdated");

        BookDTO dto = new BookDTO();
        dto.setName("Новое имя");
        dto.setPublishingCompany("OtherPub");

        Book updated = new Book();
        updated.setIsbn("ISBN-123");
        updated.setName("Новое имя");

        when(bookService.updateBook(eq("ISBN-123"), any(Book.class))).thenReturn(updated);

        mockMvc.perform(put("/api/books/{isbn}", "ISBN-123")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("Новое имя"));
    }

    @Test
    void updateBook_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: updateBook_ShouldReturnNotFoundIfMissing");

        when(bookService.updateBook(eq("NOT-EXIST"), any(Book.class))).thenThrow(new RuntimeException("Not found"));

        BookDTO dto = new BookDTO();
        dto.setName("Книга");

        mockMvc.perform(put("/api/books/{isbn}", "NOT-EXIST")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isNotFound());
    }

    @Test
    void deleteBook_ShouldReturnNoContent() throws Exception {
        logger.info("Тест контроллера: deleteBook_ShouldReturnNoContent");

        mockMvc.perform(delete("/api/books/{isbn}", "ISBN-123"))
                .andExpect(status().isNoContent());

        verify(bookService, times(1)).deleteBook("ISBN-123");
    }

    @Test
    void deleteBook_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: deleteBook_ShouldReturnNotFoundIfMissing");

        doThrow(new RuntimeException("Not found")).when(bookService).deleteBook("NOT-EXIST");

        mockMvc.perform(delete("/api/books/{isbn}", "NOT-EXIST"))
                .andExpect(status().isNotFound());
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\controller\bookstyles\BookStylesControllerTest.java =====

package org.application.bookstorage.controller.bookstyles;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.application.bookstorage.dao.Book;
import org.application.bookstorage.dao.Styles;
import org.application.bookstorage.dao.BookStyles;
import org.application.bookstorage.dao.BookStylesId;
import org.application.bookstorage.dto.BookStylesDTO;
import org.application.bookstorage.service.book.BookService;
import org.application.bookstorage.service.bookstyles.BookStylesService;
import org.application.bookstorage.service.styles.StylesService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

import java.util.*;

import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ExtendWith(SpringExtension.class)
@WebMvcTest(BookStylesController.class)
class BookStylesControllerTest {

    private static final Logger logger = LoggerFactory.getLogger(BookStylesControllerTest.class);

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private BookStylesService bookStylesService;
    @MockitoBean
    private BookService bookService;
    @MockitoBean
    private StylesService stylesService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void createBookStyles_ShouldReturnCreated() throws Exception {
        logger.info("Тест контроллера: createBookStyles_ShouldReturnCreated");

        BookStylesDTO dto = new BookStylesDTO();
        dto.setBookIsbn("ISBN-123");
        dto.setStyleId(1L);

        Book book = new Book();
        book.setIsbn("ISBN-123");
        Styles style = new Styles();
        style.setId(1L);

        when(bookService.getBookByIsbn("ISBN-123")).thenReturn(Optional.of(book));
        when(stylesService.getStyleById(1L)).thenReturn(Optional.of(style));

        BookStyles entity = new BookStyles(new BookStylesId("ISBN-123", 1L), book, style);
        when(bookStylesService.createBookStyles(any(BookStyles.class))).thenReturn(entity);

        mockMvc.perform(post("/api/book-styles")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isCreated());
    }

    @Test
    void getBookStylesById_ShouldReturnOkIfFound() throws Exception {
        logger.info("Тест контроллера: getBookStylesById_ShouldReturnOkIfFound");

        when(bookStylesService.getBookStylesById(new BookStylesId("ISBN-123", 1L)))
                .thenReturn(Optional.of(new BookStyles()));

        mockMvc.perform(get("/api/book-styles/ISBN-123/1"))
                .andExpect(status().isOk());
    }

    @Test
    void getBookStylesById_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: getBookStylesById_ShouldReturnNotFoundIfMissing");

        when(bookStylesService.getBookStylesById(new BookStylesId("NOBOOK", 999L)))
                .thenReturn(Optional.empty());

        mockMvc.perform(get("/api/book-styles/NOBOOK/999"))
                .andExpect(status().isNotFound());
    }

    @Test
    void getAllBookStyles_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: getAllBookStyles_ShouldReturnOk");

        when(bookStylesService.getAllBookStyles()).thenReturn(Collections.emptyList());

        mockMvc.perform(get("/api/book-styles"))
                .andExpect(status().isOk());
    }

    @Test
    void updateBookStyles_ShouldReturnOkIfUpdated() throws Exception {
        logger.info("Тест контроллера: updateBookStyles_ShouldReturnOkIfUpdated");

        BookStylesDTO dto = new BookStylesDTO();
        dto.setBookIsbn("ISBN-456");
        dto.setStyleId(2L);

        Book book = new Book();
        book.setIsbn("ISBN-456");
        Styles style = new Styles();
        style.setId(2L);

        when(bookService.getBookByIsbn("ISBN-456")).thenReturn(Optional.of(book));
        when(stylesService.getStyleById(2L)).thenReturn(Optional.of(style));

        BookStyles oldEntity = new BookStyles(new BookStylesId("ISBN-123", 1L), null, null);
        BookStylesId oldId = new BookStylesId("ISBN-123", 1L);

        when(bookStylesService.updateBookStyles(eq(oldId), any(BookStyles.class))).thenReturn(oldEntity);
        mockMvc.perform(put("/api/book-styles/ISBN-123/1")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isOk());
    }

    @Test
    void updateBookStyles_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: updateBookStyles_ShouldReturnNotFoundIfMissing");

        BookStylesDTO dto = new BookStylesDTO();
        dto.setBookIsbn("NoBook");
        dto.setStyleId(999L);

        when(bookService.getBookByIsbn("NoBook")).thenReturn(Optional.empty());

        mockMvc.perform(put("/api/book-styles/ISBN-123/1")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isNotFound());
    }

    @Test
    void deleteBookStyles_ShouldReturnNoContent() throws Exception {
        logger.info("Тест контроллера: deleteBookStyles_ShouldReturnNoContent");

        mockMvc.perform(delete("/api/book-styles/{bookIsbn}/{styleId}", "ISBN-123", 1L))
                .andExpect(status().isNoContent());

        verify(bookStylesService, times(1))
                .deleteBookStyles(new BookStylesId("ISBN-123", 1L));
    }

    @Test
    void deleteBookStyles_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: deleteBookStyles_ShouldReturnNotFoundIfMissing");

        doThrow(new RuntimeException("Not found")).when(bookStylesService)
                .deleteBookStyles(new BookStylesId("NOBOOK", 999L));

        mockMvc.perform(delete("/api/book-styles/NOBOOK/999"))
                .andExpect(status().isNotFound());
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\controller\csv\CsvControllerTest.java =====

package org.application.bookstorage.controller.csv;

import org.application.bookstorage.service.csv.CsvService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

import java.io.IOException;

import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ExtendWith(SpringExtension.class)
@WebMvcTest(CsvController.class)
class CsvControllerTest {

    private static final Logger logger = LoggerFactory.getLogger(CsvControllerTest.class);

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private CsvService csvService;

    @Test
    void exportData_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: exportData_ShouldReturnOk");

        mockMvc.perform(post("/api/csv/export")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk());

        verify(csvService, times(1)).exportData();
    }

    @Test
    void exportData_ShouldReturnErrorIfException() throws Exception {
        logger.info("Тест контроллера: exportData_ShouldReturnErrorIfException");

        doThrow(new IOException("IO Error")).when(csvService).exportData();

        mockMvc.perform(post("/api/csv/export"))
                .andExpect(status().isInternalServerError())
                .andExpect(content().string("Ошибка при экспорте данных: IO Error"));
    }

    @Test
    void importData_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: importData_ShouldReturnOk");

        mockMvc.perform(post("/api/csv/import"))
                .andExpect(status().isOk());

        verify(csvService, times(1)).importData();
    }

    @Test
    void importData_ShouldReturnErrorIfException() throws Exception {
        logger.info("Тест контроллера: importData_ShouldReturnErrorIfException");

        doThrow(new IOException("IO Error")).when(csvService).importData();

        mockMvc.perform(post("/api/csv/import"))
                .andExpect(status().isInternalServerError())
                .andExpect(content().string("Ошибка при импорте данных: IO Error"));
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\controller\publishingcompany\PublishingCompanyControllerTest.java =====

package org.application.bookstorage.controller.publishingcompany;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.application.bookstorage.dao.PublishingCompany;
import org.application.bookstorage.dto.PublishingCompanyDTO;
import org.application.bookstorage.service.publishingcompany.PublishingCompanyService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

import java.time.LocalDate;
import java.util.*;

import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ExtendWith(SpringExtension.class)
@WebMvcTest(PublishingCompanyController.class)
class PublishingCompanyControllerTest {

    private static final Logger logger = LoggerFactory.getLogger(PublishingCompanyControllerTest.class);

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private PublishingCompanyService publishingCompanyService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void createPublishingCompany_ShouldReturnCreated() throws Exception {
        logger.info("Тест контроллера: createPublishingCompany_ShouldReturnCreated");
        PublishingCompanyDTO dto = new PublishingCompanyDTO();
        dto.setName("NewPub");
        dto.setEstablishmentYear(LocalDate.of(1900,1,1));
        dto.setCity("City");
        dto.setContactInfo("Some info");

        PublishingCompany saved = new PublishingCompany("NewPub", LocalDate.of(1900,1,1), "Some info", "City", null);
        when(publishingCompanyService.createPublishingCompany(any(PublishingCompany.class))).thenReturn(saved);

        mockMvc.perform(post("/api/publishing-companies")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.name").value("NewPub"));
    }

    @Test
    void createPublishingCompany_ShouldReturnBadRequestIfError() throws Exception {
        logger.info("Тест контроллера: createPublishingCompany_ShouldReturnBadRequestIfError");

        when(publishingCompanyService.createPublishingCompany(any(PublishingCompany.class)))
                .thenThrow(new RuntimeException("Error"));

        PublishingCompanyDTO dto = new PublishingCompanyDTO();
        dto.setName("BadPub");

        mockMvc.perform(post("/api/publishing-companies")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest());
    }

    @Test
    void getPublishingCompanyByName_ShouldReturnOkIfFound() throws Exception {
        logger.info("Тест контроллера: getPublishingCompanyByName_ShouldReturnOkIfFound");
        PublishingCompany pc = new PublishingCompany("PubName", null, null, null, null);
        when(publishingCompanyService.getPublishingCompanyByName("PubName")).thenReturn(Optional.of(pc));

        mockMvc.perform(get("/api/publishing-companies/PubName"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("PubName"));
    }

    @Test
    void getPublishingCompanyByName_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: getPublishingCompanyByName_ShouldReturnNotFoundIfMissing");

        when(publishingCompanyService.getPublishingCompanyByName("NotFound")).thenReturn(Optional.empty());

        mockMvc.perform(get("/api/publishing-companies/NotFound"))
                .andExpect(status().isNotFound());
    }

    @Test
    void getAllPublishingCompanies_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: getAllPublishingCompanies_ShouldReturnOk");

        when(publishingCompanyService.getAllPublishingCompanies()).thenReturn(Collections.emptyList());

        mockMvc.perform(get("/api/publishing-companies"))
                .andExpect(status().isOk());
    }

    @Test
    void updatePublishingCompany_ShouldReturnOkIfUpdated() throws Exception {
        logger.info("Тест контроллера: updatePublishingCompany_ShouldReturnOkIfUpdated");
        PublishingCompanyDTO dto = new PublishingCompanyDTO();
        dto.setName("NewPub");
        dto.setCity("NewCity");

        PublishingCompany updated = new PublishingCompany("NewPub", null, null, "NewCity", null);
        when(publishingCompanyService.updatePublishingCompany(eq("OldPub"), any(PublishingCompany.class)))
                .thenReturn(updated);

        mockMvc.perform(put("/api/publishing-companies/{originalName}", "OldPub")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("NewPub"))
                .andExpect(jsonPath("$.city").value("NewCity"));
    }

    @Test
    void updatePublishingCompany_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: updatePublishingCompany_ShouldReturnNotFoundIfMissing");

        when(publishingCompanyService.updatePublishingCompany(eq("WrongPub"), any(PublishingCompany.class)))
                .thenThrow(new RuntimeException("Not found"));

        PublishingCompanyDTO dto = new PublishingCompanyDTO();
        dto.setName("SomePub");

        mockMvc.perform(put("/api/publishing-companies/{originalName}", "WrongPub")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isNotFound());
    }

    @Test
    void deletePublishingCompaniesBulk_ShouldReturnNoContent() throws Exception {
        logger.info("Тест контроллера: deletePublishingCompaniesBulk_ShouldReturnNoContent");

        List<String> names = Arrays.asList("Pub1", "Pub2");

        mockMvc.perform(delete("/api/publishing-companies/bulk-delete")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(names)))
                .andExpect(status().isNoContent());

        verify(publishingCompanyService, times(1)).deletePublishingCompanies(names);
    }

    @Test
    void deletePublishingCompaniesBulk_ShouldReturnNotFoundIfError() throws Exception {
        logger.info("Тест контроллера: deletePublishingCompaniesBulk_ShouldReturnNotFoundIfError");

        doThrow(new RuntimeException("Not found")).when(publishingCompanyService).deletePublishingCompanies(anyList());

        List<String> names = Arrays.asList("Pub1");

        mockMvc.perform(delete("/api/publishing-companies/bulk-delete")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(names)))
                .andExpect(status().isNotFound());
    }

    @Test
    void searchPublishingCompanies_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: searchPublishingCompanies_ShouldReturnOk");

        PublishingCompany pc = new PublishingCompany("SearchPub", null, null, null, null);
        when(publishingCompanyService.searchPublishingCompaniesByName("Search")).thenReturn(Collections.singletonList(pc));

        mockMvc.perform(get("/api/publishing-companies/search").param("q", "Search"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].name").value("SearchPub"));
    }
}


===== bookstorage/src/test/java/org/application/bookstorage\controller\styles\StylesControllerTest.java =====

package org.application.bookstorage.controller.styles;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.application.bookstorage.dao.Styles;
import org.application.bookstorage.dto.StylesDTO;
import org.application.bookstorage.service.styles.StylesService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.bean.override.mockito.MockitoBean;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;

import java.util.*;

import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@ExtendWith(SpringExtension.class)
@WebMvcTest(StylesController.class)
class StylesControllerTest {

    private static final Logger logger = LoggerFactory.getLogger(StylesControllerTest.class);

    @Autowired
    private MockMvc mockMvc;

    @MockitoBean
    private StylesService stylesService;

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Test
    void createStyle_ShouldReturnCreated() throws Exception {
        logger.info("Тест контроллера: createStyle_ShouldReturnCreated");
        StylesDTO dto = new StylesDTO();
        dto.setName("Новый Стиль");

        Styles created = new Styles(1L, "Новый Стиль", null);
        when(stylesService.createStyle(any(Styles.class))).thenReturn(created);

        mockMvc.perform(post("/api/styles")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.name").value("Новый Стиль"));
    }

    @Test
    void createStyle_ShouldReturnBadRequestIfError() throws Exception {
        logger.info("Тест контроллера: createStyle_ShouldReturnBadRequestIfError");
        when(stylesService.createStyle(any(Styles.class))).thenThrow(new RuntimeException("Error"));

        StylesDTO dto = new StylesDTO();
        dto.setName("BadStyle");

        mockMvc.perform(post("/api/styles")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isBadRequest());
    }

    @Test
    void getStyleById_ShouldReturnOkIfFound() throws Exception {
        logger.info("Тест контроллера: getStyleById_ShouldReturnOkIfFound");
        Styles style = new Styles(1L, "Стиль", null);

        when(stylesService.getStyleById(1L)).thenReturn(Optional.of(style));

        mockMvc.perform(get("/api/styles/{id}", 1L))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("Стиль"));
    }

    @Test
    void getStyleById_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: getStyleById_ShouldReturnNotFoundIfMissing");
        when(stylesService.getStyleById(999L)).thenReturn(Optional.empty());

        mockMvc.perform(get("/api/styles/{id}", 999L))
                .andExpect(status().isNotFound());
    }

    @Test
    void getAllStyles_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: getAllStyles_ShouldReturnOk");
        when(stylesService.getAllStyles()).thenReturn(Collections.emptyList());

        mockMvc.perform(get("/api/styles"))
                .andExpect(status().isOk());
    }

    @Test
    void updateStyle_ShouldReturnOkIfFound() throws Exception {
        logger.info("Тест контроллера: updateStyle_ShouldReturnOkIfFound");
        StylesDTO dto = new StylesDTO();
        dto.setName("Обновленный стиль");

        Styles updated = new Styles(1L, "Обновленный стиль", null);

        when(stylesService.updateStyle(eq(1L), any(Styles.class))).thenReturn(updated);

        mockMvc.perform(put("/api/styles/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("Обновленный стиль"));
    }

    @Test
    void updateStyle_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: updateStyle_ShouldReturnNotFoundIfMissing");
        when(stylesService.updateStyle(eq(999L), any(Styles.class))).thenThrow(new RuntimeException("Not found"));

        StylesDTO dto = new StylesDTO();
        dto.setName("Неизвестный");

        mockMvc.perform(put("/api/styles/{id}", 999L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(dto)))
                .andExpect(status().isNotFound());
    }

    @Test
    void deleteStyle_ShouldReturnNoContentIfDeleted() throws Exception {
        logger.info("Тест контроллера: deleteStyle_ShouldReturnNoContentIfDeleted");

        mockMvc.perform(delete("/api/styles/{id}", 1L))
                .andExpect(status().isNoContent());

        verify(stylesService, times(1)).deleteStyle(1L);
    }

    @Test
    void deleteStyle_ShouldReturnNotFoundIfMissing() throws Exception {
        logger.info("Тест контроллера: deleteStyle_ShouldReturnNotFoundIfMissing");
        doThrow(new RuntimeException("Not found")).when(stylesService).deleteStyle(999L);

        mockMvc.perform(delete("/api/styles/{id}", 999L))
                .andExpect(status().isNotFound());
    }

    @Test
    void searchStyles_ShouldReturnOk() throws Exception {
        logger.info("Тест контроллера: searchStyles_ShouldReturnOk");
        Styles style = new Styles(1L, "Ужасы", null);
        when(stylesService.searchStylesByName("уж")).thenReturn(Collections.singletonList(style));

        mockMvc.perform(get("/api/styles/search").param("q", "уж"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$[0].name").value("Ужасы"));
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\service\author\AuthorServiceTest.java =====

package org.application.bookstorage.service.author;

import org.application.bookstorage.dao.Author;
import org.application.bookstorage.dao.Book;
import org.application.bookstorage.repository.AuthorRepository;
import org.application.bookstorage.repository.BookRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuthorServiceTest {

    private static final Logger logger = LoggerFactory.getLogger(AuthorServiceTest.class);

    @Mock
    private AuthorRepository authorRepository;

    @Mock
    private BookRepository bookRepository;

    @InjectMocks
    private AuthorServiceImpl authorService;

    private Author author1;
    private Author author2;

    @BeforeEach
    void setUp() {
        author1 = new Author(1, "Иванов Иван Иванович", "1990-01-01", "Россия", "ivivan", null);
        author2 = new Author(2, "Петров Пётр Петрович", "1985-05-05", "Россия", "petrov", null);
    }

    @Test
    void createAuthor_ShouldSaveAuthor() {
        logger.info("Тест: createAuthor_ShouldSaveAuthor");
        when(authorRepository.save(any(Author.class))).thenReturn(author1);

        Author savedAuthor = authorService.createAuthor(author1);

        assertNotNull(savedAuthor);
        assertEquals(author1.getId(), savedAuthor.getId());
        verify(authorRepository, times(1)).save(author1);
    }

    @Test
    void getAuthorById_ShouldReturnAuthorIfExists() {
        logger.info("Тест: getAuthorById_ShouldReturnAuthorIfExists");
        when(authorRepository.findById(1)).thenReturn(Optional.of(author1));

        Optional<Author> result = authorService.getAuthorById(1);

        assertTrue(result.isPresent());
        assertEquals(author1.getFio(), result.get().getFio());
        verify(authorRepository, times(1)).findById(1);
    }

    @Test
    void getAuthorById_ShouldReturnEmptyIfNotFound() {
        logger.info("Тест: getAuthorById_ShouldReturnEmptyIfNotFound");
        when(authorRepository.findById(999)).thenReturn(Optional.empty());

        Optional<Author> result = authorService.getAuthorById(999);

        assertFalse(result.isPresent());
        verify(authorRepository, times(1)).findById(999);
    }

    @Test
    void getAllAuthors_ShouldReturnAllAuthors() {
        logger.info("Тест: getAllAuthors_ShouldReturnAllAuthors");
        List<Author> authors = Arrays.asList(author1, author2);
        when(authorRepository.findAll()).thenReturn(authors);

        List<Author> result = authorService.getAllAuthors();

        assertEquals(2, result.size());
        verify(authorRepository, times(1)).findAll();
    }

    @Test
    void updateAuthor_ShouldUpdateExistingAuthor() {
        logger.info("Тест: updateAuthor_ShouldUpdateExistingAuthor");
        when(authorRepository.findById(1)).thenReturn(Optional.of(author1));
        when(authorRepository.save(author1)).thenReturn(author1);

        Author newData = new Author();
        newData.setFio("Обновлённый Автор");

        Author updated = authorService.updateAuthor(1, newData);

        assertEquals("Обновлённый Автор", updated.getFio());
        verify(authorRepository, times(1)).findById(1);
        verify(authorRepository, times(1)).save(author1);
    }

    @Test
    void updateAuthor_ShouldThrowExceptionIfNotFound() {
        logger.info("Тест: updateAuthor_ShouldThrowExceptionIfNotFound");
        when(authorRepository.findById(999)).thenReturn(Optional.empty());

        Author newData = new Author();

        assertThrows(RuntimeException.class, () -> authorService.updateAuthor(999, newData));
        verify(authorRepository, times(1)).findById(999);
        verify(authorRepository, never()).save(any(Author.class));
    }

    @Test
    void deleteAuthor_ShouldDeleteExistingAuthor() {
        logger.info("Тест: deleteAuthor_ShouldDeleteExistingAuthor");
        when(authorRepository.findById(1)).thenReturn(Optional.of(author1));

        authorService.deleteAuthor(1);

        verify(authorRepository, times(1)).findById(1);
        verify(authorRepository, times(1)).delete(author1);
    }

    @Test
    void deleteAuthor_ShouldThrowExceptionIfNotFound() {
        logger.info("Тест: deleteAuthor_ShouldThrowExceptionIfNotFound");
        when(authorRepository.findById(999)).thenReturn(Optional.empty());

        assertThrows(RuntimeException.class, () -> authorService.deleteAuthor(999));
        verify(authorRepository, times(1)).findById(999);
        verify(authorRepository, never()).delete(any(Author.class));
    }

    @Test
    void searchAuthorsByFio_ShouldReturnList() {
        logger.info("Тест: searchAuthorsByFio_ShouldReturnList");
        String fio = "Иван";
        when(authorRepository.findByFioContainingIgnoreCase(fio)).thenReturn(Collections.singletonList(author1));

        List<Author> result = authorService.searchAuthorsByFio(fio);

        assertEquals(1, result.size());
        verify(authorRepository, times(1)).findByFioContainingIgnoreCase(fio);
    }

    @Test
    void searchAuthors_ShouldReturnListByFioOrNickname() {
        logger.info("Тест: searchAuthors_ShouldReturnListByFioOrNickname");
        String query = "ivan";
        when(authorRepository.findByFioContainingIgnoreCaseOrNicknameContainingIgnoreCase(query, query))
                .thenReturn(Collections.singletonList(author1));

        List<Author> result = authorService.searchAuthors(query);

        assertEquals(1, result.size());
        verify(authorRepository, times(1))
                .findByFioContainingIgnoreCaseOrNicknameContainingIgnoreCase(query, query);
    }

    @Test
    void deleteAuthors_ShouldDoNothingIfRemoveEverythingFalse() {
        logger.info("Тест: deleteAuthors_ShouldDoNothingIfRemoveEverythingFalse");
        // при removeEverything = false удаление не происходит
        authorService.deleteAuthors(Arrays.asList(1,2), false);

        verify(authorRepository, never()).findAllById(any());
        verify(bookRepository, never()).delete(any(Book.class));
        verify(authorRepository, never()).deleteAll(any());
    }

    @Test
    void deleteAuthors_ShouldDeleteAuthorsAndBooksIfRemoveEverythingTrue() {
        logger.info("Тест: deleteAuthors_ShouldDeleteAuthorsAndBooksIfRemoveEverythingTrue");

        // Допустим, у автора1 есть одна книга
        Book book = new Book();
        book.setIsbn("978-5-389-65432-1");

        // И у автора есть связь authorship
        // упростим проверку, просто смоделируем ситуацию

        Set<Book> books = new HashSet<>();
        books.add(book);

        // Мокаем возвращение авторов
        when(authorRepository.findAllById(Arrays.asList(1,2))).thenReturn(Arrays.asList(author1, author2));

        // author1 связан с book, author2 - нет
        // упростим: author1.getAuthorships() -> Set с одним элементом, который содержит book
        // Но у нас автор1.authorships = null. Смоделируем вручную:

        // Для упрощения логики создадим Set книг, где book.authorships содержит author1
        // (В реальности нужно было бы создать Authorship). Упрощаем ради теста.

        // Поступим так: ручной обход для удаления книг в сервисе "deleteAuthors".
        // Просто проверим, что всё дошло до репозиториев.

        authorService.deleteAuthors(Arrays.asList(1,2), true);

        verify(authorRepository, times(1)).findAllById(Arrays.asList(1,2));
        verify(bookRepository, times(1)).delete(any(Book.class));
        verify(authorRepository, times(1)).deleteAll(any());
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\service\authorship\AuthorshipServiceTest.java =====

package org.application.bookstorage.service.authorship;

import org.application.bookstorage.dao.Authorship;
import org.application.bookstorage.dao.AuthorshipId;
import org.application.bookstorage.repository.AuthorshipRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class AuthorshipServiceTest {

    private static final Logger logger = LoggerFactory.getLogger(AuthorshipServiceTest.class);

    @Mock
    private AuthorshipRepository authorshipRepository;

    @InjectMocks
    private AuthorshipServiceImpl authorshipService;

    private Authorship authorship;
    private AuthorshipId authorshipId;

    @BeforeEach
    void setUp() {
        authorshipId = new AuthorshipId("isbn-123", 10);
        authorship = new Authorship(authorshipId, null, null);
    }

    @Test
    void createAuthorship_ShouldSave() {
        logger.info("Тест: createAuthorship_ShouldSave");
        when(authorshipRepository.save(authorship)).thenReturn(authorship);

        Authorship result = authorshipService.createAuthorship(authorship);

        assertNotNull(result);
        verify(authorshipRepository, times(1)).save(authorship);
    }

    @Test
    void getAuthorshipById_ShouldReturnOptional() {
        logger.info("Тест: getAuthorshipById_ShouldReturnOptional");
        when(authorshipRepository.findById(authorshipId)).thenReturn(Optional.of(authorship));

        Optional<Authorship> result = authorshipService.getAuthorshipById(authorshipId);

        assertTrue(result.isPresent());
        verify(authorshipRepository, times(1)).findById(authorshipId);
    }

    @Test
    void getAllAuthorships_ShouldReturnList() {
        logger.info("Тест: getAllAuthorships_ShouldReturnList");
        List<Authorship> data = Collections.singletonList(authorship);
        when(authorshipRepository.findAll()).thenReturn(data);

        List<Authorship> result = authorshipService.getAllAuthorships();

        assertEquals(1, result.size());
        verify(authorshipRepository, times(1)).findAll();
    }

    @Test
    void updateAuthorship_ShouldUpdateIfExists() {
        logger.info("Тест: updateAuthorship_ShouldUpdateIfExists");
        when(authorshipRepository.findById(authorshipId)).thenReturn(Optional.of(authorship));
        when(authorshipRepository.save(authorship)).thenReturn(authorship);

        Authorship newData = new Authorship(authorshipId, null, null);
        Authorship updated = authorshipService.updateAuthorship(authorshipId, newData);

        assertNotNull(updated);
        verify(authorshipRepository, times(1)).findById(authorshipId);
        verify(authorshipRepository, times(1)).save(authorship);
    }

    @Test
    void updateAuthorship_ShouldThrowIfNotFound() {
        logger.info("Тест: updateAuthorship_ShouldThrowIfNotFound");
        when(authorshipRepository.findById(authorshipId)).thenReturn(Optional.empty());

        Authorship newData = new Authorship(authorshipId, null, null);

        assertThrows(RuntimeException.class, () -> authorshipService.updateAuthorship(authorshipId, newData));
        verify(authorshipRepository, times(1)).findById(authorshipId);
    }

    @Test
    void deleteAuthorship_ShouldDeleteIfExists() {
        logger.info("Тест: deleteAuthorship_ShouldDeleteIfExists");
        when(authorshipRepository.findById(authorshipId)).thenReturn(Optional.of(authorship));

        authorshipService.deleteAuthorship(authorshipId);

        verify(authorshipRepository, times(1)).findById(authorshipId);
        verify(authorshipRepository, times(1)).delete(authorship);
    }

    @Test
    void deleteAuthorship_ShouldThrowIfNotFound() {
        logger.info("Тест: deleteAuthorship_ShouldThrowIfNotFound");
        when(authorshipRepository.findById(authorshipId)).thenReturn(Optional.empty());

        assertThrows(RuntimeException.class, () -> authorshipService.deleteAuthorship(authorshipId));
        verify(authorshipRepository, times(1)).findById(authorshipId);
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\service\book\BookServiceTest.java =====

package org.application.bookstorage.service.book;

import org.application.bookstorage.dao.Book;
import org.application.bookstorage.repository.BookRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.domain.Sort;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class BookServiceTest {

    private static final Logger logger = LoggerFactory.getLogger(BookServiceTest.class);

    @Mock
    private BookRepository bookRepository;

    @InjectMocks
    private BookServiceImpl bookService;

    private Book book1;
    private Book book2;

    @BeforeEach
    void setUp() {
        book1 = new Book(
                "ISBN-123",
                "Книга 1",
                LocalDate.of(2020, 1, 1),
                18.0f,
                null,
                300,
                "Russian",
                BigDecimal.valueOf(500.0),
                10,
                null,
                null
        );
        book2 = new Book(
                "ISBN-456",
                "Книга 2",
                LocalDate.of(2021, 2, 2),
                12.0f,
                null,
                200,
                "English",
                BigDecimal.valueOf(300.0),
                5,
                null,
                null
        );
    }

    @Test
    void createBook_ShouldSaveBook() {
        logger.info("Тест: createBook_ShouldSaveBook");
        when(bookRepository.save(book1)).thenReturn(book1);

        Book savedBook = bookService.createBook(book1);

        assertNotNull(savedBook);
        assertEquals(book1.getIsbn(), savedBook.getIsbn());
        verify(bookRepository, times(1)).save(book1);
    }

    @Test
    void getBookByIsbn_ShouldReturnBookIfExists() {
        logger.info("Тест: getBookByIsbn_ShouldReturnBookIfExists");
        when(bookRepository.findById("ISBN-123")).thenReturn(Optional.of(book1));

        Optional<Book> result = bookService.getBookByIsbn("ISBN-123");

        assertTrue(result.isPresent());
        assertEquals("Книга 1", result.get().getName());
        verify(bookRepository, times(1)).findById("ISBN-123");
    }

    @Test
    void getBookByIsbn_ShouldReturnEmptyIfNotFound() {
        logger.info("Тест: getBookByIsbn_ShouldReturnEmptyIfNotFound");
        when(bookRepository.findById("NON-EXIST")).thenReturn(Optional.empty());

        Optional<Book> result = bookService.getBookByIsbn("NON-EXIST");

        assertFalse(result.isPresent());
        verify(bookRepository, times(1)).findById("NON-EXIST");
    }

    @Test
    void getAllBooks_ShouldReturnListWithOrWithoutSearch() {
        logger.info("Тест: getAllBooks_ShouldReturnListWithOrWithoutSearch");
        List<Book> books = Arrays.asList(book1, book2);
        when(bookRepository.findAll(Sort.unsorted())).thenReturn(books);

        List<Book> result = bookService.getAllBooks(null, null, null);

        assertEquals(2, result.size());
        verify(bookRepository, times(1)).findAll(Sort.unsorted());
    }

    @Test
    void updateBook_ShouldUpdateIfFound() {
        logger.info("Тест: updateBook_ShouldUpdateIfFound");
        when(bookRepository.findById("ISBN-123")).thenReturn(Optional.of(book1));
        when(bookRepository.save(book1)).thenReturn(book1);

        Book newData = new Book();
        newData.setName("Новое название");
        newData.setAgeLimit(16.0f);

        Book updated = bookService.updateBook("ISBN-123", newData);

        assertEquals("Новое название", updated.getName());
        assertEquals(16.0f, updated.getAgeLimit());
        verify(bookRepository, times(1)).findById("ISBN-123");
        verify(bookRepository, times(1)).save(book1);
    }

    @Test
    void updateBook_ShouldThrowIfNotFound() {
        logger.info("Тест: updateBook_ShouldThrowIfNotFound");
        when(bookRepository.findById("NOT-FOUND")).thenReturn(Optional.empty());

        Book newData = new Book();

        assertThrows(RuntimeException.class, () -> bookService.updateBook("NOT-FOUND", newData));
        verify(bookRepository, times(1)).findById("NOT-FOUND");
        verify(bookRepository, never()).save(any(Book.class));
    }

    @Test
    void deleteBook_ShouldDeleteIfFound() {
        logger.info("Тест: deleteBook_ShouldDeleteIfFound");
        when(bookRepository.findById("ISBN-123")).thenReturn(Optional.of(book1));

        bookService.deleteBook("ISBN-123");

        verify(bookRepository, times(1)).findById("ISBN-123");
        verify(bookRepository, times(1)).delete(book1);
    }

    @Test
    void deleteBook_ShouldThrowIfNotFound() {
        logger.info("Тест: deleteBook_ShouldThrowIfNotFound");
        when(bookRepository.findById("NOT-FOUND")).thenReturn(Optional.empty());

        assertThrows(RuntimeException.class, () -> bookService.deleteBook("NOT-FOUND"));
        verify(bookRepository, times(1)).findById("NOT-FOUND");
        verify(bookRepository, never()).delete(any(Book.class));
    }

    @Test
    void deleteBooks_ShouldDeleteAllIfFound() {
        logger.info("Тест: deleteBooks_ShouldDeleteAllIfFound");
        List<String> isbns = Arrays.asList("ISBN-123", "ISBN-456");
        when(bookRepository.findAllById(isbns)).thenReturn(Arrays.asList(book1, book2));

        bookService.deleteBooks(isbns);

        verify(bookRepository, times(1)).findAllById(isbns);
        verify(bookRepository, times(1)).deleteAll(anyList());
    }

    @Test
    void deleteBooks_ShouldThrowIfNotAllFound() {
        logger.info("Тест: deleteBooks_ShouldThrowIfNotAllFound");
        List<String> isbns = Arrays.asList("ISBN-123", "ISBN-999");
        when(bookRepository.findAllById(isbns)).thenReturn(Collections.singletonList(book1));

        assertThrows(RuntimeException.class, () -> bookService.deleteBooks(isbns));
        verify(bookRepository, times(1)).findAllById(isbns);
        verify(bookRepository, never()).deleteAll(anyList());
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\service\bookstyles\BookStylesServiceTest.java =====

package org.application.bookstorage.service.bookstyles;

import org.application.bookstorage.dao.BookStyles;
import org.application.bookstorage.dao.BookStylesId;
import org.application.bookstorage.repository.BookStylesRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class BookStylesServiceTest {

    private static final Logger logger = LoggerFactory.getLogger(BookStylesServiceTest.class);

    @Mock
    private BookStylesRepository bookStylesRepository;

    @InjectMocks
    private BookStylesServiceImpl bookStylesService;

    private BookStylesId id;
    private BookStyles bookStyles;

    @BeforeEach
    void setUp() {
        id = new BookStylesId("ISBN-123", 1L);
        bookStyles = new BookStyles(id, null, null);
    }

    @Test
    void createBookStyles_ShouldSave() {
        logger.info("Тест: createBookStyles_ShouldSave");
        when(bookStylesRepository.save(bookStyles)).thenReturn(bookStyles);

        BookStyles result = bookStylesService.createBookStyles(bookStyles);

        assertNotNull(result);
        verify(bookStylesRepository, times(1)).save(bookStyles);
    }

    @Test
    void getBookStylesById_ShouldReturnOptional() {
        logger.info("Тест: getBookStylesById_ShouldReturnOptional");
        when(bookStylesRepository.findById(id)).thenReturn(Optional.of(bookStyles));

        Optional<BookStyles> result = bookStylesService.getBookStylesById(id);

        assertTrue(result.isPresent());
        verify(bookStylesRepository, times(1)).findById(id);
    }

    @Test
    void getAllBookStyles_ShouldReturnList() {
        logger.info("Тест: getAllBookStyles_ShouldReturnList");
        List<BookStyles> data = Collections.singletonList(bookStyles);
        when(bookStylesRepository.findAll()).thenReturn(data);

        List<BookStyles> result = bookStylesService.getAllBookStyles();

        assertEquals(1, result.size());
        verify(bookStylesRepository, times(1)).findAll();
    }

    @Test
    void updateBookStyles_ShouldUpdateIfFound() {
        logger.info("Тест: updateBookStyles_ShouldUpdateIfFound");
        when(bookStylesRepository.findById(id)).thenReturn(Optional.of(bookStyles));
        when(bookStylesRepository.save(bookStyles)).thenReturn(bookStyles);

        BookStyles newData = new BookStyles(id, null, null);
        BookStyles updated = bookStylesService.updateBookStyles(id, newData);

        assertNotNull(updated);
        verify(bookStylesRepository, times(1)).findById(id);
        verify(bookStylesRepository, times(1)).save(bookStyles);
    }

    @Test
    void updateBookStyles_ShouldThrowIfNotFound() {
        logger.info("Тест: updateBookStyles_ShouldThrowIfNotFound");
        when(bookStylesRepository.findById(id)).thenReturn(Optional.empty());

        BookStyles newData = new BookStyles(id, null, null);

        assertThrows(RuntimeException.class, () -> bookStylesService.updateBookStyles(id, newData));
        verify(bookStylesRepository, times(1)).findById(id);
    }

    @Test
    void deleteBookStyles_ShouldDeleteIfFound() {
        logger.info("Тест: deleteBookStyles_ShouldDeleteIfFound");
        when(bookStylesRepository.findById(id)).thenReturn(Optional.of(bookStyles));

        bookStylesService.deleteBookStyles(id);

        verify(bookStylesRepository, times(1)).findById(id);
        verify(bookStylesRepository, times(1)).delete(bookStyles);
    }

    @Test
    void deleteBookStyles_ShouldThrowIfNotFound() {
        logger.info("Тест: deleteBookStyles_ShouldThrowIfNotFound");
        when(bookStylesRepository.findById(id)).thenReturn(Optional.empty());

        assertThrows(RuntimeException.class, () -> bookStylesService.deleteBookStyles(id));
        verify(bookStylesRepository, times(1)).findById(id);
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\service\csv\CsvServiceTest.java =====

package org.application.bookstorage.service.csv;

import com.opencsv.exceptions.CsvValidationException;
import org.application.bookstorage.dao.*;
import org.application.bookstorage.repository.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.time.LocalDate;
import java.util.*;

import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class CsvServiceTest {

    private static final Logger logger = LoggerFactory.getLogger(CsvServiceTest.class);

    @Mock
    private AuthorRepository authorRepository;

    @Mock
    private PublishingCompanyRepository publishingCompanyRepository;

    @Mock
    private BookRepository bookRepository;

    @Mock
    private AuthorshipRepository authorshipRepository;

    @Mock
    private StylesRepository stylesRepository;

    @Mock
    private BookStylesRepository bookStylesRepository;

    @InjectMocks
    private CsvService csvService;

    private Author author;
    private PublishingCompany pc;
    private Book book;
    private Authorship authorship;
    private Styles style;
    private BookStyles bookStyles;

    @BeforeEach
    void setUp() {
        author = new Author(1, "Test Author", "2000-01-01", "Country", "Nick", null);
        pc = new PublishingCompany("TestPub", LocalDate.of(1999,1,1), "Info", "City", null);
        book = new Book("ISBN-123", "Test Book", LocalDate.of(2020,1,1), 18F,
                pc, 100, "Russian", null, 10, null, null);
        authorship = new Authorship(new AuthorshipId("ISBN-123", 1), book, author);
        style = new Styles(1L, "Test Style", null);
        bookStyles = new BookStyles(new BookStylesId("ISBN-123", 1L), book, style);
    }

    @Test
    void exportData_ShouldCallExportMethods() throws IOException {
        logger.info("Тест: exportData_ShouldCallExportMethods");

        // Просто вызываем csvService.exportData() и проверяем, что не упало
        // В реальном проекте стоит подменять файловую систему (Mock файлов), тут же просто smoke-тест
        csvService.exportData();

        // Не можем проверить точный результат записи в файлы, т.к. нельзя менять CsvService (подменять потоки)
        // Но можно удостовериться, что сервис как минимум пытался взять сущности из репозиториев

        verify(authorRepository, atLeastOnce()).findAll();
        verify(publishingCompanyRepository, atLeastOnce()).findAll();
        verify(stylesRepository, atLeastOnce()).findAll();
        verify(bookRepository, atLeastOnce()).findAll();
        verify(authorshipRepository, atLeastOnce()).findAll();
        verify(bookStylesRepository, atLeastOnce()).findAll();
    }

    @Test
    void importData_ShouldCallImportMethods() throws IOException, CsvValidationException {
        logger.info("Тест: importData_ShouldCallImportMethods");

        // Аналогично — здесь просто проверяем, что метод вызывается
        csvService.importData();

        // Поскольку мы не можем переопределить чтение файлов, всё происходит "тихо".
        // В реальном окружении стоило бы подменить CSV-файлы на тестовые.

        // Основная проверка — нет исключений и есть какие-то вызовы репозиториев в процессе
        // Например, может вызываться findById, save и т.п. Мы не видим точные вызовы в данном примере,
        // но можем проверить минимум, что метод вообще вызывается
        // (Конечно, нужно изучать логику CsvService, если нужно более точное тестирование.)

        verifyNoMoreInteractions(
                authorRepository,
                publishingCompanyRepository,
                bookRepository,
                authorshipRepository,
                stylesRepository,
                bookStylesRepository
        );
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\service\publishingcompany\PublishingCompanyServiceTest.java =====

package org.application.bookstorage.service.publishingcompany;

import org.application.bookstorage.dao.Book;
import org.application.bookstorage.dao.PublishingCompany;
import org.application.bookstorage.repository.BookRepository;
import org.application.bookstorage.repository.PublishingCompanyRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDate;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class PublishingCompanyServiceTest {

    private static final Logger logger = LoggerFactory.getLogger(PublishingCompanyServiceTest.class);

    @Mock
    private PublishingCompanyRepository publishingCompanyRepository;

    @Mock
    private BookRepository bookRepository;

    @InjectMocks
    private PublishingCompanyServiceImpl publishingCompanyService;

    private PublishingCompany pc1;

    @BeforeEach
    void setUp() {
        pc1 = new PublishingCompany(
                "MyPublisher",
                LocalDate.of(2000,1,1),
                "Some contacts",
                "Moscow",
                null
        );
    }

    @Test
    void createPublishingCompany_ShouldSave() {
        logger.info("Тест: createPublishingCompany_ShouldSave");
        when(publishingCompanyRepository.save(pc1)).thenReturn(pc1);

        PublishingCompany result = publishingCompanyService.createPublishingCompany(pc1);

        assertNotNull(result);
        verify(publishingCompanyRepository, times(1)).save(pc1);
    }

    @Test
    void getPublishingCompanyByName_ShouldReturnIfFound() {
        logger.info("Тест: getPublishingCompanyByName_ShouldReturnIfFound");
        when(publishingCompanyRepository.findById("MyPublisher")).thenReturn(Optional.of(pc1));

        Optional<PublishingCompany> result = publishingCompanyService.getPublishingCompanyByName("MyPublisher");

        assertTrue(result.isPresent());
        assertEquals("MyPublisher", result.get().getName());
        verify(publishingCompanyRepository, times(1)).findById("MyPublisher");
    }

    @Test
    void getAllPublishingCompanies_ShouldReturnList() {
        logger.info("Тест: getAllPublishingCompanies_ShouldReturnList");
        when(publishingCompanyRepository.findAll()).thenReturn(Collections.singletonList(pc1));

        List<PublishingCompany> result = publishingCompanyService.getAllPublishingCompanies();

        assertEquals(1, result.size());
        verify(publishingCompanyRepository, times(1)).findAll();
    }

    @Test
    void updatePublishingCompany_ShouldUpdateIfSameName() {
        logger.info("Тест: updatePublishingCompany_ShouldUpdateIfSameName");
        when(publishingCompanyRepository.findById("MyPublisher")).thenReturn(Optional.of(pc1));
        when(publishingCompanyRepository.save(pc1)).thenReturn(pc1);

        PublishingCompany newData = new PublishingCompany();
        newData.setName("MyPublisher"); // то же имя
        newData.setCity("Saint-Petersburg");

        PublishingCompany result = publishingCompanyService.updatePublishingCompany("MyPublisher", newData);

        assertEquals("Saint-Petersburg", result.getCity());
        verify(publishingCompanyRepository, times(1)).findById("MyPublisher");
        verify(publishingCompanyRepository, times(1)).save(pc1);
    }

    @Test
    void updatePublishingCompany_ShouldRenameIfDifferentNameAndNotExists() {
        logger.info("Тест: updatePublishingCompany_ShouldRenameIfDifferentNameAndNotExists");
        when(publishingCompanyRepository.findById("MyPublisher")).thenReturn(Optional.of(pc1));
        when(publishingCompanyRepository.existsById("NewName")).thenReturn(false);

        // Мокаем создание новой записи
        PublishingCompany newPC = new PublishingCompany("NewName", null, null, null, null);
        when(publishingCompanyRepository.save(any(PublishingCompany.class))).thenReturn(newPC);

        // Тоже нужно замокать удаление старой
        doNothing().when(publishingCompanyRepository).delete(pc1);

        PublishingCompany updatedData = new PublishingCompany();
        updatedData.setName("NewName");
        updatedData.setCity("Perm");

        PublishingCompany result = publishingCompanyService.updatePublishingCompany("MyPublisher", updatedData);

        assertNotNull(result);
        assertEquals("NewName", result.getName());
        verify(publishingCompanyRepository, times(1)).findById("MyPublisher");
        verify(publishingCompanyRepository, times(1)).existsById("NewName");
        verify(publishingCompanyRepository, times(1)).save(any(PublishingCompany.class));
        verify(publishingCompanyRepository, times(1)).delete(pc1);
    }

    @Test
    void updatePublishingCompany_ShouldThrowIfOldNotFound() {
        logger.info("Тест: updatePublishingCompany_ShouldThrowIfOldNotFound");
        when(publishingCompanyRepository.findById("Wrong")).thenReturn(Optional.empty());

        PublishingCompany updatedData = new PublishingCompany();
        updatedData.setName("NewName");

        assertThrows(RuntimeException.class, () -> publishingCompanyService.updatePublishingCompany("Wrong", updatedData));
        verify(publishingCompanyRepository, times(1)).findById("Wrong");
    }

    @Test
    void deletePublishingCompanies_ShouldDeleteAllIfFound() {
        logger.info("Тест: deletePublishingCompanies_ShouldDeleteAllIfFound");
        when(publishingCompanyRepository.findAllById(Arrays.asList("MyPublisher"))).thenReturn(Collections.singletonList(pc1));

        publishingCompanyService.deletePublishingCompanies(Collections.singletonList("MyPublisher"));

        verify(publishingCompanyRepository, times(1)).findAllById(anyList());
        verify(publishingCompanyRepository, times(1)).deleteAll(anyList());
    }

    @Test
    void deletePublishingCompanies_ShouldThrowIfNotFound() {
        logger.info("Тест: deletePublishingCompanies_ShouldThrowIfNotFound");
        when(publishingCompanyRepository.findAllById(anyList())).thenReturn(Collections.emptyList());

        assertThrows(RuntimeException.class, () ->
                publishingCompanyService.deletePublishingCompanies(Collections.singletonList("WrongName")));
        verify(publishingCompanyRepository, times(1)).findAllById(anyList());
        verify(publishingCompanyRepository, never()).deleteAll(anyList());
    }

    @Test
    void searchPublishingCompaniesByName_ShouldReturnList() {
        logger.info("Тест: searchPublishingCompaniesByName_ShouldReturnList");
        when(publishingCompanyRepository.findByNameContainingIgnoreCase("Publ"))
                .thenReturn(Collections.singletonList(pc1));

        List<PublishingCompany> result = publishingCompanyService.searchPublishingCompaniesByName("Publ");

        assertEquals(1, result.size());
        verify(publishingCompanyRepository, times(1)).findByNameContainingIgnoreCase("Publ");
    }
}



===== bookstorage/src/test/java/org/application/bookstorage\service\styles\StylesServiceTest.java =====

package org.application.bookstorage.service.styles;

import org.application.bookstorage.dao.Styles;
import org.application.bookstorage.repository.StylesRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class StylesServiceTest {

    private static final Logger logger = LoggerFactory.getLogger(StylesServiceTest.class);

    @Mock
    private StylesRepository stylesRepository;

    @InjectMocks
    private StylesServiceImpl stylesService;

    private Styles style1;

    @BeforeEach
    void setUp() {
        style1 = new Styles(1L, "Ужасы", null);
    }

    @Test
    void createStyle_ShouldSave() {
        logger.info("Тест: createStyle_ShouldSave");
        when(stylesRepository.save(style1)).thenReturn(style1);

        Styles result = stylesService.createStyle(style1);

        assertNotNull(result);
        verify(stylesRepository, times(1)).save(style1);
    }

    @Test
    void getStyleById_ShouldReturnIfExists() {
        logger.info("Тест: getStyleById_ShouldReturnIfExists");
        when(stylesRepository.findById(1L)).thenReturn(Optional.of(style1));

        Optional<Styles> result = stylesService.getStyleById(1L);

        assertTrue(result.isPresent());
        assertEquals("Ужасы", result.get().getName());
        verify(stylesRepository, times(1)).findById(1L);
    }

    @Test
    void getAllStyles_ShouldReturnList() {
        logger.info("Тест: getAllStyles_ShouldReturnList");
        when(stylesRepository.findAll()).thenReturn(Collections.singletonList(style1));

        List<Styles> result = stylesService.getAllStyles();

        assertEquals(1, result.size());
        verify(stylesRepository, times(1)).findAll();
    }

    @Test
    void updateStyle_ShouldUpdateIfFound() {
        logger.info("Тест: updateStyle_ShouldUpdateIfFound");
        when(stylesRepository.findById(1L)).thenReturn(Optional.of(style1));
        when(stylesRepository.save(style1)).thenReturn(style1);

        Styles newData = new Styles();
        newData.setName("Комедия");

        Styles updated = stylesService.updateStyle(1L, newData);

        assertEquals("Комедия", updated.getName());
        verify(stylesRepository, times(1)).findById(1L);
        verify(stylesRepository, times(1)).save(style1);
    }

    @Test
    void updateStyle_ShouldThrowIfNotFound() {
        logger.info("Тест: updateStyle_ShouldThrowIfNotFound");
        when(stylesRepository.findById(999L)).thenReturn(Optional.empty());

        Styles newData = new Styles();

        assertThrows(RuntimeException.class, () -> stylesService.updateStyle(999L, newData));
        verify(stylesRepository, times(1)).findById(999L);
        verify(stylesRepository, never()).save(any(Styles.class));
    }

    @Test
    void deleteStyle_ShouldDeleteIfFound() {
        logger.info("Тест: deleteStyle_ShouldDeleteIfFound");
        when(stylesRepository.findById(1L)).thenReturn(Optional.of(style1));

        stylesService.deleteStyle(1L);

        verify(stylesRepository, times(1)).findById(1L);
        verify(stylesRepository, times(1)).delete(style1);
    }

    @Test
    void deleteStyle_ShouldThrowIfNotFound() {
        logger.info("Тест: deleteStyle_ShouldThrowIfNotFound");
        when(stylesRepository.findById(999L)).thenReturn(Optional.empty());

        assertThrows(RuntimeException.class, () -> stylesService.deleteStyle(999L));
        verify(stylesRepository, times(1)).findById(999L);
        verify(stylesRepository, never()).delete(any(Styles.class));
    }

    @Test
    void getStyleByName_ShouldReturnExactIfExists() {
        logger.info("Тест: getStyleByName_ShouldReturnExactIfExists");
        when(stylesRepository.findByNameIgnoreCase("Ужасы")).thenReturn(Optional.of(style1));

        Optional<Styles> result = stylesService.getStyleByName("Ужасы");

        assertTrue(result.isPresent());
        assertEquals("Ужасы", result.get().getName());
        verify(stylesRepository, times(1)).findByNameIgnoreCase("Ужасы");
    }

    @Test
    void getStyleByName_ShouldReturnPartialIfNoExact() {
        logger.info("Тест: getStyleByName_ShouldReturnPartialIfNoExact");
        when(stylesRepository.findByNameIgnoreCase("Комедия")).thenReturn(Optional.empty());
        when(stylesRepository.findByNameContainingIgnoreCase("Комедия"))
                .thenReturn(Collections.singletonList(style1));

        Optional<Styles> result = stylesService.getStyleByName("Комедия");

        assertTrue(result.isPresent());
        assertEquals(style1, result.get());
        verify(stylesRepository, times(1)).findByNameIgnoreCase("Комедия");
        verify(stylesRepository, times(1)).findByNameContainingIgnoreCase("Комедия");
    }

    @Test
    void getStyleByName_ShouldReturnEmptyIfNoMatches() {
        logger.info("Тест: getStyleByName_ShouldReturnEmptyIfNoMatches");
        when(stylesRepository.findByNameIgnoreCase("Foo")).thenReturn(Optional.empty());
        when(stylesRepository.findByNameContainingIgnoreCase("Foo")).thenReturn(Collections.emptyList());

        Optional<Styles> result = stylesService.getStyleByName("Foo");

        assertFalse(result.isPresent());
        verify(stylesRepository, times(1)).findByNameIgnoreCase("Foo");
        verify(stylesRepository, times(1)).findByNameContainingIgnoreCase("Foo");
    }

    @Test
    void searchStylesByName_ShouldReturnList() {
        logger.info("Тест: searchStylesByName_ShouldReturnList");
        when(stylesRepository.findByNameContainingIgnoreCase("уж")).thenReturn(Collections.singletonList(style1));

        List<Styles> result = stylesService.searchStylesByName("уж");

        assertEquals(1, result.size());
        verify(stylesRepository, times(1)).findByNameContainingIgnoreCase("уж");
    }
}

